1
00:00:00,091 --> 00:00:02,083
我们今天去个有意思的地方

2
00:00:15,009 --> 00:00:20,095
好了，试点新的东西，大家好，我是Cherno，欢迎回到cpp系列

3
00:00:21,023 --> 00:00:24,010
所以今天，头文件，我们真的在外面了！

4
00:00:24,017 --> 00:00:30,005
早上天气很好，然后开始下雨，但我决定出城，因为。。。

5
00:00:30,055 --> 00:00:34,090
所以我们在这，澳大利亚的某个地方，而且我们要讨论C++

6
00:00:35,038 --> 00:00:41,000
希望你们不要以为是我觉得头文件太无聊了，以至于我觉得有必要跑出城去才能压过这份无聊

7
00:00:41,012 --> 00:00:42,085
没有！我只是想出来而已！

8
00:00:43,012 --> 00:00:48,053
好了，头文件，它是什么，为什么我们需要他们，甚至为什么他们在C++中存在

9
00:00:48,072 --> 00:00:51,085
许多你或许已经习惯了的其他语言,比如java或者c#

10
00:00:52,008 --> 00:00:57,025
他们实际上没有头文件这个概念，也没有存在两种不同的文件类型的概念

11
00:00:57,033 --> 00:01:00,042
一种是我们的编译文件，比如说cpp文件

12
00:01:00,066 --> 00:01:05,078
也就是一个翻译单元，然后还有一种就是头文件，一个奇怪的文件

13
00:01:05,088 --> 00:01:08,055
我们经常到处include它们，为什么它会存在

14
00:01:08,073 --> 00:01:16,093
头文件实际上很有用，而且它们的用途不只是声明某种声明，以供你在多个CPP中使用而已

15
00:01:17,007 --> 00:01:22,082
随着该系列的继续下去，我们将要学习很多新概念，都需要头文件才能正常工作 

16
00:01:22,093 --> 00:01:24,047
所以请不要马上就跳过了

17
00:01:24,070 --> 00:01:33,015
在c++基础中，头文件传统上是用来声明某些函数类型，以便可以用于整个程序中

18
00:01:33,020 --> 00:01:35,065
如果你回想一下我的c++编译器和链接器视频

19
00:01:35,086 --> 00:01:43,022
我谈到了为了让我们知道什么函数和类型存在，我们需要某种声明

20
00:01:43,045 --> 00:01:47,065
比如说，我们在一个文件中创建函数，然后想要在另一个文件中使用

21
00:01:47,083 --> 00:01:52,083
当我们尝试编译时那个文件时，C++甚至都不会知道它的存在

22
00:01:53,021 --> 00:01:56,062
所以我们需要一个共同的地方来存放声明，而非定义

23
00:01:57,001 --> 00:01:58,095
因为，记住，我们只能定义函数一次

24
00:01:59,010 --> 00:02:05,022
我们需要这么一个共同的地方存放函数声明，只是声明，而没有实际的定义，没有函数的主体

25
00:02:05,038 --> 00:02:08,098
只是一个地方说“嘿，这个函数存在!" 

26
00:02:09,005 --> 00:02:16,005
假设我有个函数叫log，它将打印信息到控制台

27
00:02:16,012 --> 00:02:21,012
它接受一个const char “message”，然后单纯cout该信息

28
00:02:23,048 --> 00:02:27,055
然后，如果我继续创建另一个文件，我们将命名为log.cpp

29
00:02:27,078 --> 00:02:32,095
然后也许这个文件有个什么初始化我们到Log的，并且会log一句话到控制台

30
00:02:32,099 --> 00:02:39,043
我们拿到了一个错误，这个log函数并不存在于该文件，该文件不知道log函数的存在

31
00:02:39,052 --> 00:02:47,002
当然回到main，它在这里，log函数存在，我们可以把这里换成Log

32
00:02:47,015 --> 00:02:53,035
如果如果我按CTRL加f7试图编译我们的程序，可以看到可以正常工作，没有错误

33
00:02:53,048 --> 00:02:56,093
然后回到log文件，如果我们试图编译这个文件，我们获得一个错误

34
00:02:56,099 --> 00:03:00,007
因为显然就这个文件来说，log不存在

35
00:03:00,023 --> 00:03:03,065
所以log.cpp到底需要什么东西才能不会有错误？

36
00:03:03,067 --> 00:03:08,043
我们该如何告诉它，log这个函数存在，只是它定义于别的什么地方，

37
00:03:08,048 --> 00:03:10,080
这就是函数声明用的用武之地

38
00:03:10,089 --> 00:03:16,023
如果我们回到我们的代码这里，我只需要简单的声明，log函数存在，

39
00:03:16,025 --> 00:03:19,025
如果我们回到main函数，然后看一下这个实际的签名，

40
00:03:19,038 --> 00:03:24,038
可以看到log是一个返回void、接受一个参数——也就是一个const char*的函数，

41
00:03:24,060 --> 00:03:30,000
有小孩在追袋鼠，真搞笑，

42
00:03:30,007 --> 00:03:37,032
所以这是函数签名，我们可以直接复制这个，回到log.cpp，粘贴进来，然后用一个分号结束它，

43
00:03:37,038 --> 00:03:42,038
啊，这个函数没有主体的事实呢，说明这是一个函数的声明，

44
00:03:42,050 --> 00:03:45,065
我们还没有定义这个函数到底是什么样子，这个函数到底做什么

45
00:03:45,081 --> 00:03:52,035
我们只是说嘿，这边有一个函数叫log，返回类型是void，接受一个const char*，这个函数存在

46
00:03:52,055 --> 00:03:56,050
你可以看到我们的Intellisence的错误已经消失了，如果我按control加f7，我们可以编译，

47
00:03:56,060 --> 00:04:00,005
如果我们右击hello world，然后点build来build我们的程序，

48
00:04:00,010 --> 00:04:03,032
可以看到他也链接成功，因为这是可以的，他找到了那个log函数，

49
00:04:03,055 --> 00:04:10,090
好的非常好，我们找到了一个告诉log.cpp那个log函数存在于某处的办法，

50
00:04:10,093 --> 00:04:15,093
那如果我创建另外一个文件呢？如果我创建了一个别的文件，然后需要用这个log函数呢？

51
00:04:16,010 --> 00:04:21,010
这意味着我也需要把这个void log声明到处复制粘贴吗？

52
00:04:21,033 --> 00:04:26,033
嗯，答案是是的，你确实需要这么做，但是呢，有一个办法可以让这一切简单一点，

53
00:04:26,046 --> 00:04:34,065
头文件，什么是头文件？我其实应该说头文件传统上是什么？因为这是c加加，你可以做任何事情，

54
00:04:34,075 --> 00:04:39,017
所以头文件一般是那种被include到cpp文件里的，基本上我们做的就是，

55
00:04:39,035 --> 00:04:42,055
把头文件里的内容copy and paste到cpp文件里，

56
00:04:42,070 --> 00:04:46,030
我们通过#include这个pre processor语句来实现，

57
00:04:46,045 --> 00:04:50,033
所以#Include有从文件复制粘贴到其他文件的能力，

58
00:04:50,036 --> 00:04:52,065
这看起来正是我们需要在这里做的，

59
00:04:52,073 --> 00:04:57,027
我们需要把这个log的声明，复制粘贴到任何我们需要用这个log函数的地方，

60
00:04:57,042 --> 00:05:00,065
所以让我们去创建一个头文件，我将右击header files

61
00:05:00,075 --> 00:05:04,045
请注意这些文件夹其实是过滤器，它们不是真的文件夹，

62
00:05:04,049 --> 00:05:06,057
我也可以在source files底下创建一个头文件，

63
00:05:06,072 --> 00:05:09,052
将来我们也会有一些视频，关于visual studio是怎么工作的，

64
00:05:09,069 --> 00:05:14,010
但现在你要知道的就是，你无论在什么地方右击创建头文件都没关系，

65
00:05:14,020 --> 00:05:18,025
我将在头文件上面创建，因为这更合理一点，但实际上其实无所谓，

66
00:05:18,035 --> 00:05:24,002
我将创建一个头文件叫log点h，你会意识到它自动给你插入了一些代码，

67
00:05:24,015 --> 00:05:26,073
叫#pragma once，我们等会很快会介绍他，

68
00:05:26,085 --> 00:05:31,085
在这里我将存放我们的声明，我将从log.cpp把这个Log函数剪切，

69
00:05:31,090 --> 00:05:35,048
放入这里，放入我们的头文件，现在呢，

70
00:05:35,051 --> 00:05:40,051
我们的头文件log点h，我可以在任何想用log函数的地方include它，

71
00:05:40,052 --> 00:05:43,075
然后显然他会帮我们做那些我们不想人工做的事情，

72
00:05:43,080 --> 00:05:48,025
也就是复制粘贴这个当任何我们需要它的所有文件里，

73
00:05:48,030 --> 00:05:53,095
我不想自己去做这个复制粘贴的工作，所以就找了一个某种程度上让它看起来整洁一点，自动化一点的办法，

74
00:05:54,000 --> 00:05:59,000
回到log点cpp，你会看到我们也获得一个错误，因为我们其实没有声明这个函数，

75
00:05:59,013 --> 00:06:02,023
但如果我输入#include “log.h"，

76
00:06:02,030 --> 00:06:06,067
看哪，我们没有任何错误，然后我们的文件可以编译，非常好

77
00:06:06,077 --> 00:06:10,015
我们其实还可以做的是把它include到main点cpp，

78
00:06:10,026 --> 00:06:15,083
main.cpp包含实际的函数定义，所以其实他并不需要他，我们反正都可以调用log

79
00:06:15,098 --> 00:06:20,042
只是为了让你知道，呃，我们把它include进来也不会造成什么伤害，

80
00:06:20,045 --> 00:06:22,033
然后编译，这是完全没有问题的，

81
00:06:22,039 --> 00:06:26,067
好了，回到log点cpp，你可以看到我们定义了这个超屌的函数initlog，

82
00:06:26,069 --> 00:06:29,065
然后除了log点cpp，没人知道它，

83
00:06:29,071 --> 00:06:32,095
如果想从main里面使用它，我需要拿到它的声明，

84
00:06:32,099 --> 00:06:35,092
如果我在这里调用init log，我们会获得一个错误，

85
00:06:35,099 --> 00:06:41,098
这是因为他没有在任何地方被声明，所以让我们去log头文件把它的函数签名加进来

86
00:06:42,005 --> 00:06:47,083
就像这样非常好，只是要确保它和cpp文件里的实际签名一致，

87
00:06:47,095 --> 00:06:53,067
所以现在一切都看起来很好，然后我要去把这个log函数拿到这个log.cpp来，

88
00:06:53,077 --> 00:06:57,095
因为这样看起来更合理一点，我们这边会有一个错误告诉我cout没有被找到，

89
00:06:58,020 --> 00:07:00,045
没关系，我可以include iostream，很好，

90
00:07:00,055 --> 00:07:06,045
回到main，如果运行我们的程序，看我们实际上初始化了log并打印了，hello，world到控制台，

91
00:07:06,052 --> 00:07:13,002
非常好，Ok非常好，我们回到那个头文件，看一下那个pragma once到底是什么

92
00:07:13,027 --> 00:07:18,005
所以这里我们有一个语句是看起来是visual studio给我们生成的，叫#pragma once，

93
00:07:18,015 --> 00:07:24,010
这是什么？任何以一个井号开头的语句都被称为一个预处理命令，或者叫预处理指令，

94
00:07:24,017 --> 00:07:30,010
也就意味着他将在这个文件被编译之前被c++的pre processor评估，

95
00:07:30,020 --> 00:07:34,040
pragma其实是一个被输入到编译器或者说预处理器的指令，

96
00:07:34,042 --> 00:07:39,042
pragma once其实意思就是说只include这个文件一次，

97
00:07:39,056 --> 00:07:41,057
Pragma once, 是一种被称为header guard(头文件保护符）

98
00:07:41,063 --> 00:07:48,008
他所做的就是防止我们把单个头文件多次include到一个单一翻译单元里，

99
00:07:48,012 --> 00:07:56,095
现在我说话其实很小心的，你得明白，他其实不会防止我们把头文件include到程序的各处，

100
00:07:56,098 --> 00:08:01,038
只是防止include到一个翻译单元里，也就是一个单独的cpp文件，

101
00:08:01,042 --> 00:08:06,065
原因是如果我们不小心把一个文件多次include到一个翻译单元里，

102
00:08:06,067 --> 00:08:11,042
我们会得到一个重复的错误，因为我们会多次复制和粘贴那个头文件

103
00:08:11,045 --> 00:08:15,002
一个比较好的办法来示意这种情况是我们创建一个struct.

104
00:08:15,015 --> 00:08:19,008
比如说如果我在这里创建一个struct叫做player.我可以就让他空着，没关系，

105
00:08:19,009 --> 00:08:24,077
如果我把这个文件，两次应付得到一个翻译单元，并且没有头文件保护符，

106
00:08:24,092 --> 00:08:30,052
他会真的include这个文件两次，也就是我会有两个structs, 他们有相同的名字，player，

107
00:08:30,060 --> 00:08:33,053
我们可以通过把这个pragma once评论掉来看一下这个例子

108
00:08:33,056 --> 00:08:36,060
然后回到log，我会include log.h两次，

109
00:08:36,073 --> 00:08:40,035
如果我试图编译我的文件，你可以看到我们拿到了一个player structure重复定义的错误，

110
00:08:40,042 --> 00:08:46,030
因为我们在重新定义这个player struct,而我们只能定义一个叫player的struct，Struct的需要唯一的名字

111
00:08:46,040 --> 00:08:50,047
所以你会问”cherno我为什么要这样做，我不是个傻程序员 

112
00:08:50,050 --> 00:08:53,070
我没你想象到那么傻，我为什么要include一个文件两次？”

113
00:08:53,078 --> 00:08:57,025
唉年轻人，这又回到了include到底是怎么工作的

114
00:08:57,028 --> 00:09:00,015
记得吗，include的工作方法就是从一个文件复制粘贴到另一个文件，

115
00:09:00,023 --> 00:09:03,003
也就是说你可能会有一个一连串的include

116
00:09:03,010 --> 00:09:07,030
所以你可能有一个头文件叫player，他会include log，然后player又被include到其他的文件，

117
00:09:07,035 --> 00:09:10,072
然后可能那第3个文件会包含所有的include，

118
00:09:10,081 --> 00:09:14,003
所以如果我创建一个新的头文件，叫common，

119
00:09:14,008 --> 00:09:19,008
Common将会包含一些常用的 includes，比如它会include log

120
00:09:19,018 --> 00:09:22,057
如果我回到log.h，确保program once被评论掉了，

121
00:09:22,057 --> 00:09:26,045
然后在log.cpp，我include log.h和common.h，

122
00:09:26,047 --> 00:09:29,030
如果我编译我的文件，猜猜会怎样？我仍然拿到那个错误，

123
00:09:29,034 --> 00:09:31,088
因为那个struct player被重新定义了，

124
00:09:31,098 --> 00:09:37,057
如果我们要解析预处理器到底做了什么,你可以看到他其实有把log include两次，

125
00:09:37,065 --> 00:09:42,017
然而回到log.h，如果我们把评论去掉，并试图编译我们的文件，

126
00:09:42,023 --> 00:09:47,023
我们没有任何错误，因为它认识到log已经被include了，他不会第2次再include它，

127
00:09:47,038 --> 00:09:52,028
还有另外一种方式来添加一个头文件保护符，作为教学目的来说，我其实更喜欢它

128
00:09:52,030 --> 00:09:57,030
因为它比什么pragma once更有意义一点看上去，虽然pragma once看起来更干净，

129
00:09:57,043 --> 00:10:00,060
传统的办法添加头文件保护符，其实是通过if def

130
00:10:00,064 --> 00:10:07,003
我们可以做的就是输入#ifndef，然后我们可以来检查某种符号，比如说_log_h，

131
00:10:07,008 --> 00:10:13,010
然后我们会定义_log_h，然后在我们文章的最后，输入 endif

132
00:10:13,015 --> 00:10:18,015
这个将要做的就是首先他会检查这个log h这个符号是否存在，

133
00:10:18,022 --> 00:10:23,000
如果没有被定义，他将把以下代码include到编译里，

134
00:10:23,005 --> 00:10:27,090
如果这个被定义了，那这些都不会被include，会全部被禁用，

135
00:10:28,000 --> 00:10:31,047
当我们通过了，第1个条件检查，我们会定义log h，

136
00:10:31,050 --> 00:10:36,088
也就是说下一次我们运行这段代码时，它是已经被定义的状态，所以不会再重复，

137
00:10:36,092 --> 00:10:44,005
最简单的办法来描述这个东西就是复制粘贴整个文件，到我们的log.cpp文件，

138
00:10:44,015 --> 00:10:53,010
如果我们看一下它，我也把log.h评论掉，以及common.h

139
00:10:53,022 --> 00:10:58,022
所以你们看在这里，第1次时，这一切都OK，他include了这个文件，一切正常

140
00:10:58,028 --> 00:11:02,092
但第2次，他都是灰色，因为log_h已经被定义了，

141
00:11:02,097 --> 00:11:12,010
所以这种形式的头文件保护符在过去经常使用，然而我们现在有这个新的预处理语句叫pragma once，所以我们现在大多数用它，

142
00:11:12,015 --> 00:11:15,078
从某种意义上来说，其实你用哪种都无所谓，虽然pragma once看起来更干净，

143
00:11:15,086 --> 00:11:20,015
所以我更青睐于用它，而且在行业里这也是绝大部分人所用的，

144
00:11:20,021 --> 00:11:25,021
基本上现在所有的编辑器都支持pragma once，所以并不是只是适用于vs

145
00:11:25,028 --> 00:11:31,008
gcc、clang、msbc，它们都支持pragma once，所以别怕用它

146
00:11:31,015 --> 00:11:40,003
话说回来，如果你有看到老代码，或者别人写过到不同风格的代码，你会碰到这个ifndef头文件保护符，所以就知道一下它是啥
 

147
00:11:40,008 --> 00:11:43,038
不过我永远不会写ifndef，我会写pragma once

148
00:11:43,043 --> 00:11:48,020
我想给你展示的最后一件事是，在头文件保护符一起，我们在include语句间有一些差异

149
00:11:48,022 --> 00:11:54,005
有些include语句用引号，有些include语句用方括号，所以到底啥情况？

150
00:11:54,012 --> 00:11:58,030
其实很简单，他们代表两件事，当我们编译我们的程序时

151
00:11:58,035 --> 00:12:06,097
我们有办法告诉编译器某些include路径，这基本上就是在我们电脑里通往文件夹的路径，它们包含include文件

152
00:12:07,003 --> 00:12:11,040
如果我们想要include的那个文件，在这些文件夹其中之一的话，

153
00:12:11,046 --> 00:12:16,046
我们可以用方括号去让编译器在所有include路径里，去搜索这个文件，

154
00:12:16,057 --> 00:12:21,090
而引号用于include文件存在于该文件的相对位置，

155
00:12:22,015 --> 00:12:27,078
举例来说，如果我有一个文件叫做log.h，它存在于目前这个log点cpp文件的上一级目录，

156
00:12:27,088 --> 00:12:34,080
我可以用../来返回，而这会返回上一级目录，因为这是相对于本文件的位置，

157
00:12:34,088 --> 00:12:41,040
而对于方括号来说，永远没有说这个文件的相对位置，他们必须存在于所有include目录的某一个里，

158
00:12:41,047 --> 00:12:47,000
我们会在以后的视频里讲怎么设置include目录和这所有东西，我不想现在把事情搞得太复杂，但这基本上就是他的工作原理，

159
00:12:47,003 --> 00:12:54,033
现在引号也可以用于include目录的位置，通过编译器

160
00:12:54,049 --> 00:13:01,062
所以你其实可以在任何地方用引号，我可以把iostream这个换成引号，将完全没问题

161
00:13:01,072 --> 00:13:05,092
所以方括号只用于编译器的include路径，引号用于所有

162
00:13:05,096 --> 00:13:10,096
但我一般喜欢只将它用于相对位置，还不如把方括号用起来

163
00:13:11,004 --> 00:13:17,003
ok，今天最后一件事，你可能发现这个iostream看起来不像个文件

164
00:13:17,010 --> 00:13:21,060
因为它没有扩展名，就叫iostream，这是怎么一回事呢

165
00:13:21,072 --> 00:13:28,085
其实，它是个文件，只是没有扩展名，写标准库的人决定这么干的

166
00:13:28,097 --> 00:13:41,050
为了区分c的标准库和c++标准库，c标准库里的头文件一般都有.h扩展名，而c++没有

167
00:13:41,065 --> 00:13:48,067
所以这也是一个区分哪些属于c标准库，哪些属于c++标准库的办法，就是是否有.h扩展名

168
00:13:48,070 --> 00:13:54,055
iostream跟其他东西一样，就是个文件，其实，在vs里，右击它，点击打开文件

169
00:13:54,067 --> 00:13:57,033
你可以看到它带领我们来到这个iostream头文件

170
00:13:57,039 --> 00:14:01,028
如果我们在这个标签上右击，选择打开包含文件夹

171
00:14:01,030 --> 00:14:06,097
可以看到它其实位于我们的计算机，在这个目录下，在这里，iostream文件

172
00:14:07,000 --> 00:14:12,000
ok，这就是了，头文件，很简单，我们在该系列会大量运用它

173
00:14:12,019 --> 00:14:17,019
所以会有很多的例子，你可以看我是怎么用它的，你会看到你该如何使用它

174
00:14:17,026 --> 00:14:20,005
但你现在应该懂了它们如何工作，以及它们被用于何处

175
00:14:20,009 --> 00:14:26,050
不管怎样，我得走了，真的越来越冷了（后面不翻译了，请转英文字幕）

