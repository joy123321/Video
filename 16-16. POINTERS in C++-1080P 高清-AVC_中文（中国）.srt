1
00:00:00,000 --> 00:00:00,003
啊

2
00:00:04,080 --> 00:00:05,055
开始了

3
00:00:05,055 --> 00:00:05,076
嘿

4
00:00:05,076 --> 00:00:06,036
大家好

5
00:00:06,036 --> 00:00:09,070
我的名字是Cherno，欢迎回到我的C++系列

6
00:00:09,078 --> 00:00:10,056
所以今天

7
00:00:10,056 --> 00:00:14,088
可能是整个系列中最重要的一集

8
00:00:14,088 --> 00:00:16,014
我们要来讲指针

9
00:00:16,014 --> 00:00:16,071
不幸的是

10
00:00:16,071 --> 00:00:19,062
很多人觉得指针很难

11
00:00:19,062 --> 00:00:21,012
所以我真的想说

12
00:00:21,012 --> 00:00:21,078
别担心

13
00:00:21,078 --> 00:00:23,013
别把它想的太复杂 

14
00:00:23,013 --> 00:00:25,032
指针其实很简单

15
00:00:25,032 --> 00:00:29,016
我还想说的是，今天我们要讲的是原始指针(raw pointer)而非智能指针(smart pointer)

16
00:00:29,016 --> 00:00:30,063
如果你不知道什么是智能指针

17
00:00:30,063 --> 00:00:32,085
那就别管了，我们以后会讲到的

18
00:00:32,085 --> 00:00:34,011
计算机跟内存打交道

19
00:00:34,011 --> 00:00:36,056
内存是计算机的一切

20
00:00:36,056 --> 00:00:39,099
如果我必须说出编程中唯一最重要的东西

21
00:00:39,099 --> 00:00:41,046
它可能是内存(memory)

22
00:00:41,046 --> 00:00:43,059
当你编写一个应用程序并启动它时

23
00:00:43,059 --> 00:00:46,056
整个的程序被载入内存

24
00:00:46,056 --> 00:00:50,097
在你写的代码中，所有的指令告诉计算机要做什么

25
00:00:50,097 --> 00:00:52,083
所有这些都被加载到内存中

26
00:00:52,083 --> 00:00:59,055
这就是CPU如何访问你的程序并执行指令的方法，当你创建一个变量时

27
00:00:59,055 --> 00:01:01,053
当你从硬盘中载入数据时

28
00:01:01,053 --> 00:01:03,066
所有东西都会被存储在内存中

29
00:01:03,066 --> 00:01:11,067
如果没有内存，你将什么也做不了。而指针对管理和操纵那个内存极其重要 

30
00:01:11,067 --> 00:01:13,005
所以什么是指针？

31
00:01:13,005 --> 00:01:16,050
在这个视频中，我可能会多次重复

32
00:01:16,050 --> 00:01:18,009
指针是一个整数

33
00:01:18,009 --> 00:01:20,079
一个数字，它存储一个内存地址

34
00:01:20,079 --> 00:01:22,038
这就是它的全部

35
00:01:22,038 --> 00:01:25,050
我不想太深入讨论内存在计算机中是如何工作的

36
00:01:25,050 --> 00:01:27,048
我可能会另做一个视频讲它

37
00:01:27,048 --> 00:01:32,070
但将你电脑里的内存想象成一整块

38
00:01:32,073 --> 00:01:36,006
像很长的一条线，它就是这么回事而已

39
00:01:36,006 --> 00:01:42,054
想象一条街，如果你居住的整个城市都有一条街，有一个起点，有一个终点

40
00:01:42,054 --> 00:01:45,036
然后有很多房子，我们别去想马路对面的房子，对面没有！

41
00:01:45,036 --> 00:01:49,080
我们就假设有一条街，然后一整排房子

42
00:01:49,080 --> 00:01:51,084
这就是内存在电脑里的样子

43
00:01:51,084 --> 00:01:59,034
它只是一个线性的、一维的线，这条街上的每栋房子都有一个门牌号和地址

44
00:01:59,034 --> 00:02:01,059
所以把这个比喻放到电脑身上

45
00:02:01,059 --> 00:02:05,046
把那条街上每个带地址的房子想象成一个byte

46
00:02:05,046 --> 00:02:07,017
它是一个字节的数据

47
00:02:07,017 --> 00:02:09,081
我们显然需要一种方法来给所有bytes取址

48
00:02:09,081 --> 00:02:11,076
也就是我们街上所有的房子取址

49
00:02:11,076 --> 00:02:12,021
因为

50
00:02:12,021 --> 00:02:12,096
例如

51
00:02:12,096 --> 00:02:16,014
假设有人在网上订购了一些东西，并想要送货上门

52
00:02:16,014 --> 00:02:21,099
它需要被送到正确的房子里。或者是有人寄东西，他们把东西从他们的房子里送出去

53
00:02:21,099 --> 00:02:22,089
不管怎样

54
00:02:22,089 --> 00:02:27,056
您需要能够从内存中，从那些bytes中、也就是那些房子中，读取和写入

55
00:02:27,056 --> 00:02:34,047
指针就是那个地址，告诉我们房子在哪——那个特定的字节的内存在哪

56
00:02:34,047 --> 00:02:35,076
这是非常重要的

57
00:02:35,076 --> 00:02:42,018
因为我们在代码中所做的每一件事，都是从内存中读取或者写入内存

58
00:02:42,018 --> 00:02:42,036
现在

59
00:02:42,036 --> 00:02:42,072
当然

60
00:02:42,072 --> 00:02:50,055
如果你用c++写程序完全不用指针也是完全可行的，你可以这样做，没有说一定要用指针

61
00:02:50,055 --> 00:02:50,091
然而

62
00:02:50,091 --> 00:02:53,043
它们是非常有用的工具，因为

63
00:02:53,043 --> 00:02:54,033
正如我刚才提到的

64
00:02:54,033 --> 00:02:57,042
内存可能是你所拥有的最重要的东西

65
00:02:57,042 --> 00:03:00,030
你的电脑所能提供的最重要的资源

66
00:03:00,030 --> 00:03:04,083
所有东西都依赖它，所以能够对这些内存有更多的控制至关重要

67
00:03:04,083 --> 00:03:05,007
好了

68
00:03:05,007 --> 00:03:05,057
不管怎样

69
00:03:07,048 --> 00:03:09,039
重申一下

70
00:03:09,039 --> 00:03:12,024
一个指针只是一个地址

71
00:03:12,024 --> 00:03:15,036
它是一个整数，存储着一个内存地址

72
00:03:15,036 --> 00:03:17,088
这就是它的全部，别管什么类型

73
00:03:17,088 --> 00:03:19,095
类型与这些没有任何关系

74
00:03:19,095 --> 00:03:24,006
类型只是我们虚构出来的，好让我们过的更轻松

75
00:03:24,006 --> 00:03:26,004
不管你是有个int指针

76
00:03:26,004 --> 00:03:28,080
还是你有个entity类，然后有个entity指针

77
00:03:28,080 --> 00:03:29,088
这无关紧要

78
00:03:29,088 --> 00:03:32,067
类型... 类型完全（挥舞手势）没有意义

79
00:03:32,067 --> 00:03:33,021
好吗？

80
00:03:33,021 --> 00:03:38,088
所有类型的指针都是一个整数，存放一个内存地址

81
00:03:38,088 --> 00:03:40,014
这就是它的全部

82
00:03:40,014 --> 00:03:42,063
让我们看看一些例子

83
00:03:42,063 --> 00:03:42,087
好的

84
00:03:42,087 --> 00:03:43,080
在visualstudio中

85
00:03:43,080 --> 00:03:45,006
我有一个非常简单的项目

86
00:03:45,006 --> 00:03:46,065
它只有一个源文件

87
00:03:46,065 --> 00:03:50,049
你在屏幕上看到的所有东西就是我写的所有代码

88
00:03:50,049 --> 00:03:52,014
让我们来创建一个指针

89
00:03:52,014 --> 00:03:57,040
我们要创建最纯粹的指针，因为它是一个叫做void指针的东西

90
00:03:57,048 --> 00:03:59,082
void基本上指它是完全没有类型的

91
00:03:59,082 --> 00:04:00,051
记住

92
00:04:00,051 --> 00:04:00,084
记住

93
00:04:00,084 --> 00:04:03,045
我说过一个指针只是一个地址

94
00:04:03,045 --> 00:04:06,060
它只是一个在内存中存放地址的整数

95
00:04:06,060 --> 00:04:08,097
所以它不需要什么类型，如果我们给一个指针一个类型

96
00:04:08,097 --> 00:04:14,073
我们只是说，在那个地址的数据可能是我们给它的类型，对吧

97
00:04:14,073 --> 00:04:17,073
除了这一点 它没有任何意义

98
00:04:17,073 --> 00:04:21,090
只是我们可以写出来，让我们的生活，从语法上来说，更轻松

99
00:04:21,090 --> 00:04:25,080
在源码中让我们的生活更轻松，我们可以用指针类型

100
00:04:25,080 --> 00:04:26,010
但是，再一次

101
00:04:26,010 --> 00:04:27,096
一个类型不会改变一个指针

102
00:04:27,096 --> 00:04:29,067
一个指针只是一个内存地址

103
00:04:29,067 --> 00:04:31,011
它只是一个整数

104
00:04:31,011 --> 00:04:31,095
所以void指针

105
00:04:31,095 --> 00:04:37,020
这意味着，在源码中我们现在不关心这个数据到底是啥类型

106
00:04:37,020 --> 00:04:40,023
因为我们只想要存放一个地址

107
00:04:40,023 --> 00:04:40,080
让我们继续

108
00:04:40,080 --> 00:04:44,043
我把它简称为ptr(pointer)，把它设为0

109
00:04:44,043 --> 00:04:45,030
那么什么是0呢

110
00:04:45,030 --> 00:04:47,079
我们给了这个指针一个为0的内存地址

111
00:04:47,079 --> 00:04:48,072
这是什么意思？

112
00:04:48,072 --> 00:04:49,002
其实

113
00:04:49,002 --> 00:04:51,056
0其实不是一个有效的内存地址

114
00:04:51,056 --> 00:04:54,039
内存地址不会 一直到0

115
00:04:54,039 --> 00:04:55,059
0是无效的

116
00:04:55,059 --> 00:04:58,047
这意味着这个指针是无效的

117
00:04:58,047 --> 00:05:01,038
对于指针来说，无效是一个完全可以接受的状态

118
00:05:01,038 --> 00:05:04,095
但我这里说的是，0不是一个有效的内存地址

119
00:05:04,095 --> 00:05:08,016
我们没法读取或者写入地址为0的内存，如果我们试图这样做

120
00:05:08,016 --> 00:05:10,038
我们的程序会崩溃，所以0意味着没有

121
00:05:10,038 --> 00:05:12,039
我们也可以这样写

122
00:05:12,039 --> 00:05:14,001
这实际上只是一个#define

123
00:05:14,001 --> 00:05:16,005
如果你去看一下这个NULL到底是啥，你可以看到

124
00:05:16,005 --> 00:05:18,048
它只一个给0的 #define

125
00:05:18,048 --> 00:05:22,070
所以这和我们在这写0是一回事，或者我们可以c++的一个关键字叫nullptr

126
00:05:22,070 --> 00:05:25,020
这是在c++11引入的，awesome！

127
00:05:25,020 --> 00:05:26,052
我们已经创建了第一个指针

128
00:05:26,052 --> 00:05:30,033
它是完全没有类型的，它的内存地址为0

129
00:05:30,033 --> 00:05:34,020
完全没鸟用，但它是个指针，可能是你能写出来的最简单的指针

130
00:05:34,020 --> 00:05:36,003
让我们做一些更有用的事情

131
00:05:36,003 --> 00:05:37,017
让我们来创建一个int

132
00:05:37,017 --> 00:05:38,064
我将创建一个变量

133
00:05:38,064 --> 00:05:39,056
我把它叫做哇(var)

134
00:05:39,056 --> 00:05:42,021
我想让它等于8，它将是一个整数

135
00:05:42,021 --> 00:05:43,074
这只是一个普通的整数

136
00:05:43,074 --> 00:05:48,060
但是当然，我们创建的任何变量都有一个内存地址，因为我们需要一个存储该变量的地方

137
00:05:48,060 --> 00:05:52,059
所以，如果我想知道那个变量的内存地址是什么

138
00:05:52,059 --> 00:05:53,004
所以

139
00:05:53,004 --> 00:05:54,039
你在内存的什么位置

140
00:05:54,039 --> 00:05:57,033
我可以通过使用&运算符来实现

141
00:05:57,033 --> 00:06:01,044
所以如果我在一个现有的变量前面用一个&符号，像这样

142
00:06:01,044 --> 00:06:03,033
我们实际上是在问这个变量

143
00:06:03,033 --> 00:06:03,081
嘿

144
00:06:03,081 --> 00:06:05,025
你的内存地址是什么

145
00:06:05,025 --> 00:06:05,052
然后

146
00:06:05,052 --> 00:06:05,085
当然

147
00:06:05,085 --> 00:06:08,091
我们拿到那个变量的内存地址

148
00:06:08,091 --> 00:06:12,009
在我们这，把它赋给一个叫ptr的新变量

149
00:06:12,009 --> 00:06:12,066
就是这样

150
00:06:12,066 --> 00:06:15,054
我们现在得到了变量的内存地址

151
00:06:15,054 --> 00:06:18,000
我们把它存储在另一个变量中，一个指针中

152
00:06:18,000 --> 00:06:22,080
我将在这行代码上设置一个断点，并按F5来运行及调试我的程序

153
00:06:22,083 --> 00:06:23,031
所以现在

154
00:06:23,031 --> 00:06:24,060
如果我看一下我们现在有什么

155
00:06:24,060 --> 00:06:25,086
可以看到我们有一个变量

156
00:06:25,086 --> 00:06:27,027
我把鼠标放在上面

157
00:06:27,027 --> 00:06:28,047
它有个8的值

158
00:06:28,047 --> 00:06:30,063
如果我把鼠标悬停在这个指针上

159
00:06:30,063 --> 00:06:33,006
它的值，额，略有不同

160
00:06:33,006 --> 00:06:35,037
以16进制的形式显示的

161
00:06:35,037 --> 00:06:36,009
但它是

162
00:06:36,009 --> 00:06:36,075
如你所见

163
00:06:36,075 --> 00:06:37,080
仍然只是一个数字

164
00:06:37,080 --> 00:06:38,061
它是一个整数

165
00:06:38,061 --> 00:06:43,056
所以这个变量现在持有的是变量var的内存地址

166
00:06:43,056 --> 00:06:46,014
仅此而已，你看到的那个数字

167
00:06:46,014 --> 00:06:47,046
a0fb64

168
00:06:47,046 --> 00:06:51,084
那就是我们在内存中存储我们的整型变量的位置

169
00:06:51,084 --> 00:06:52,026
事实上

170
00:06:52,026 --> 00:06:54,030
我可以拿到它

171
00:06:54,030 --> 00:06:55,035
复制

172
00:06:55,035 --> 00:06:59,030
点Debug->Windows->Memory->memory 1

173
00:06:59,037 --> 00:07:03,063
这个视图现在显示的是我们程序内的所有内存

174
00:07:03,063 --> 00:07:05,004
我要那个值粘贴进来

175
00:07:05,004 --> 00:07:07,089
我先把前面这个ptr去掉

176
00:07:09,048 --> 00:07:10,014
然后按回车

177
00:07:10,014 --> 00:07:12,042
看哪！

178
00:07:12,042 --> 00:07:14,094
我们被带到这个内存地址

179
00:07:15,096 --> 00:07:18,081
我们知道一个整数是4字节，然后你看这个

180
00:07:18,081 --> 00:07:22,017
它有8这个值，我们正在看电脑的内存

181
00:07:22,017 --> 00:07:30,021
我们可以看到，在那个内存地址我们有值8，因为我们创建了那个变量并且设为8的

182
00:07:30,021 --> 00:07:30,087
太棒了

183
00:07:30,087 --> 00:07:32,031
这其实就。。。

184
00:07:32,031 --> 00:07:33,030
我是说。。。

185
00:07:33,030 --> 00:07:35,055
在一个基楚的层面上看，这就是这么回事而已

186
00:07:35,055 --> 00:07:37,053
其他一切都是建立在这个基础之上的

187
00:07:37,053 --> 00:07:39,087
如果你懂这么多，而且有根据自己的理解跟上我的讲解

188
00:07:39,087 --> 00:07:40,017
它。。。

189
00:07:40,017 --> 00:07:41,097
没有魔法的

190
00:07:41,097 --> 00:07:44,016
指针就是这么回事，一个指针是

191
00:07:44,016 --> 00:07:47,001
一个包含地址的变量

192
00:07:47,001 --> 00:07:47,076
一个整数

193
00:07:47,076 --> 00:07:49,035
指针就像任何其他变量一样

194
00:07:49,035 --> 00:07:51,056
只是不是存放一个值，比如说8

195
00:07:51,056 --> 00:07:52,098
而是存放一个内存地址

196
00:07:52,098 --> 00:07:54,051
一个内存地址也是值

197
00:07:54,051 --> 00:07:55,044
它也是一个整数

198
00:07:55,044 --> 00:07:55,065
那么

199
00:07:55,065 --> 00:08:01,077
这个整数有多大——这个指针有多大，取决于很多东西，它可能是一个32位的整数

200
00:08:01,077 --> 00:08:02,097
可能是64位的

201
00:08:02,097 --> 00:08:03,096
可能是16位的

202
00:08:03,096 --> 00:08:05,064
这不重要，好吗

203
00:08:05,064 --> 00:08:06,021
关键是

204
00:08:06,021 --> 00:08:07,020
它是一个整数

205
00:08:07,020 --> 00:08:08,097
它也永远只是一个整数

206
00:08:08,097 --> 00:08:13,020
如果我回到我的代码，把它变成一个整数指针

207
00:08:13,020 --> 00:08:14,076
实际上我并没有改变任何东西

208
00:08:14,076 --> 00:08:16,053
如果我再次运行程序

209
00:08:16,053 --> 00:08:18,054
你会发现没什么不同

210
00:08:18,054 --> 00:08:22,047
如果我继续复制这个值

211
00:08:22,047 --> 00:08:25,002
复制它，粘贴到内存视图

212
00:08:25,002 --> 00:08:26,070
然后按回车

213
00:08:26,070 --> 00:08:29,020
你可以看到它仍然是8

214
00:08:29,028 --> 00:08:30,030
我可以回到这里

215
00:08:30,030 --> 00:08:32,085
我可以把它变成一个完全不同的类型

216
00:08:32,085 --> 00:08:33,075
比如double

217
00:08:33,075 --> 00:08:34,008
当然

218
00:08:34,008 --> 00:08:35,049
它会在这个时候给我一个错误

219
00:08:35,049 --> 00:08:38,028
因为编译器会报警

220
00:08:38,028 --> 00:08:40,014
我可以把它cast成double的

221
00:08:40,014 --> 00:08:40,089
没关系

222
00:08:40,089 --> 00:08:42,070
我将再次运行代码

223
00:08:42,078 --> 00:08:50,097
我将看一下它的值，复制它的值，粘贴到这里，然后把后面一串垃圾都删掉，回车，然后看哪！

224
00:08:50,097 --> 00:08:54,006
它带我到内存中存储我的数据的地方

225
00:08:54,006 --> 00:08:58,098
这里有4个字节，存着8这个值，类型完全不会影响

226
00:08:58,098 --> 00:09:02,016
类型对于操纵这块内存有用

227
00:09:02,016 --> 00:09:03,075
如果我想读取和写入它

228
00:09:03,075 --> 00:09:06,087
内存类型可以帮助我，因为编译器会知道

229
00:09:06,087 --> 00:09:07,041
比如

230
00:09:07,041 --> 00:09:09,045
一个整数应该是4个字节

231
00:09:09,045 --> 00:09:11,055
所以当我要设置一个值的时候

232
00:09:11,055 --> 00:09:13,023
它会设置4个字节的内存

233
00:09:13,023 --> 00:09:13,092
但最终

234
00:09:13,092 --> 00:09:16,092
类型是完全没有意义的，在以后的视频中 

235
00:09:16,092 --> 00:09:19,014
我们将更深入地研究这个问题

236
00:09:19,014 --> 00:09:21,078
但现在，就别担心类型的事了

237
00:09:21,078 --> 00:09:22,023
好了

238
00:09:22,023 --> 00:09:25,065
让我们用回我们的void指针，好吧

239
00:09:25,065 --> 00:09:27,036
为什么我们不总使用void指针呢？

240
00:09:27,036 --> 00:09:27,045
嗯

241
00:09:27,045 --> 00:09:29,061
假设我想要读取我的数据

242
00:09:29,061 --> 00:09:32,043
我有一个指向那个数据的指针

243
00:09:32,043 --> 00:09:32,076
然而

244
00:09:32,076 --> 00:09:36,096
现在我想要写入或读取这块数据

245
00:09:36,096 --> 00:09:38,094
所以这个存储值8的变量

246
00:09:38,094 --> 00:09:40,002
我想更改它

247
00:09:40,002 --> 00:09:41,001
如何更改呢

248
00:09:41,001 --> 00:09:41,076
我该怎么。。

249
00:09:41,076 --> 00:09:42,018
我有。。

250
00:09:42,018 --> 00:09:43,028
我知道数据在哪里

251
00:09:43,028 --> 00:09:44,085
但是我怎么才访问它呢

252
00:09:44,085 --> 00:09:46,026
这时候dereferencing（解引用？）就派上用场了

253
00:09:46,026 --> 00:09:50,055
所以我们从一个var变成了一个指针指向var

254
00:09:50,055 --> 00:09:52,050
但是我怎么才能回到那个var呢

255
00:09:52,050 --> 00:09:52,080
嗯

256
00:09:52,080 --> 00:09:57,000
你可以通过在指针前面加上一个星号来实现

257
00:09:57,000 --> 00:09:57,048
换句话说

258
00:09:57,048 --> 00:09:58,089
如果我写这个

259
00:09:58,089 --> 00:10:07,011
我实际上是在解引用那个指针，也就是我现在在访问那块数据，我可以读取或者写入那块数据

260
00:10:07,011 --> 00:10:07,068
所以我可以

261
00:10:07,068 --> 00:10:08,028
例如

262
00:10:08,028 --> 00:10:10,028
将值10写入

263
00:10:10,028 --> 00:10:10,065
然而

264
00:10:10,065 --> 00:10:11,055
如果我试着这样做

265
00:10:11,055 --> 00:10:13,017
你会看到我实际上得到了一个错误

266
00:10:13,017 --> 00:10:13,059
为什么

267
00:10:13,059 --> 00:10:15,006
因为我们已经说过了

268
00:10:15,006 --> 00:10:17,025
这个指针是一个void指针

269
00:10:17,025 --> 00:10:18,063
这意味着，我的意思是怎么。。

270
00:10:18,063 --> 00:10:21,020
计算机如何才能把一个值写到一个void指针里去？

271
00:10:21,027 --> 00:10:22,023
它不知道那是什么

272
00:10:22,023 --> 00:10:23,043
这个10是short吗

273
00:10:23,043 --> 00:10:24,054
short是一个两个字节的整数

274
00:10:24,054 --> 00:10:26,073
还是一个int？int是一个4个字节的整数

275
00:10:26,073 --> 00:10:27,054
还是说是一个long long？

276
00:10:27,054 --> 00:10:29,064
那就是一个8字节的整数

277
00:10:29,064 --> 00:10:33,020
我们不知道该写入多少字节的数据，对吧？

278
00:10:33,021 --> 00:10:34,023
我们刚说它是10

279
00:10:34,023 --> 00:10:35,097
但说实话，10可能是任何东西

280
00:10:35,097 --> 00:10:36,090
这时候就要用到类型了

281
00:10:36,090 --> 00:10:37,098
我们需要告诉编译器

282
00:10:37,098 --> 00:10:38,025
“其实，

283
00:10:38,025 --> 00:10:39,070
不是，这其实是个int”

284
00:10:39,078 --> 00:10:41,010
所以我需要写入4个字节

285
00:10:41,010 --> 00:10:43,077
那么让我们把它改成int

286
00:10:43,077 --> 00:10:44,025
现在

287
00:10:44,025 --> 00:10:44,080
当然

288
00:10:44,080 --> 00:10:46,050
我们已经告诉编译器这是一个int

289
00:10:46,050 --> 00:10:50,090
是我们告诉编译器的，并不是编译器自己在那，“对，是，没错”

290
00:10:50,097 --> 00:10:52,005
是我们告诉编译器的

291
00:10:52,005 --> 00:10:52,095
如果我们搞错了

292
00:10:52,095 --> 00:10:54,078
如果我们说这是一个double

293
00:10:54,078 --> 00:10:55,080
我们可能会有麻烦

294
00:10:55,080 --> 00:10:58,062
如果我输出var的值

295
00:10:58,062 --> 00:11:01,090
也就是我们原始的变量

296
00:11:01,092 --> 00:11:04,083
你会看到我得到的值是10

297
00:11:04,083 --> 00:11:05,019
好的

298
00:11:05,019 --> 00:11:08,040
所以我们成功地把它从8变成了10

299
00:11:08,040 --> 00:11:12,051
如果我们继续，在这里设置另一个断点并运行我们的程序

300
00:11:12,051 --> 00:11:15,024
我要到watch这里，并输入这个ptr

301
00:11:15,024 --> 00:11:18,030
然后我把这个值一路拖到这里，这样我们就到了指向的内存这

302
00:11:18,030 --> 00:11:20,079
你会看到这块内存存储着8这个值

303
00:11:20,079 --> 00:11:23,055
如果我按F10来advance（前进？）一行

304
00:11:23,055 --> 00:11:26,067
你会看到现在变成了0a

305
00:11:26,067 --> 00:11:28,070
a当然就是十六进制的10了

306
00:11:28,070 --> 00:11:32,000
所以你可以看到，通过解引用一个指针并写入它

307
00:11:32,004 --> 00:11:33,072
我就上是在访问那块数据

308
00:11:33,072 --> 00:11:36,099
在我们这种情况，就是写入那块内存

309
00:11:36,099 --> 00:11:37,038
好了

310
00:11:37,038 --> 00:11:40,017
cool，现在你应该知道指针是怎么工作的

311
00:11:40,017 --> 00:11:44,040
这其实就是它们的全部，一个指针只是指向内存中的一个位置

312
00:11:44,040 --> 00:11:46,062
有些人说它指向一块内存（ a block of memory）

313
00:11:46,062 --> 00:11:50,028
虽然这不是很准确，因为我们不知道那块内存多大

314
00:11:50,028 --> 00:11:51,063
在这种情况下

315
00:11:51,063 --> 00:11:56,031
它是4字节，因为我们有一个int，一个int是4个字节的内存

316
00:11:56,031 --> 00:12:00,033
所以我们确实是有一个指针指向4个字节的一块内存

317
00:12:00,033 --> 00:12:01,002
然而

318
00:12:01,002 --> 00:12:07,050
在实际的指针中，并没有哪里有说内存有多大，当我们创建数组的时候，它有记录大小

319
00:12:07,050 --> 00:12:08,073
我不打算讲那个

320
00:12:08,073 --> 00:12:09,036
但是简单地说

321
00:12:09,036 --> 00:12:10,083
我们不知道指针有多大

322
00:12:10,083 --> 00:12:14,043
我们不知道它含有多少数据，因为它并没有保存数据，对吧

323
00:12:14,043 --> 00:12:18,012
指针只是一个整数，也就是一个内存地址

324
00:12:19,056 --> 00:12:20,049
仅此而已

325
00:12:20,049 --> 00:12:20,097
到目前为止

326
00:12:20,097 --> 00:12:23,040
我们都是直接在stack上创建数据

327
00:12:23,040 --> 00:12:24,078
如果我这样创建变量

328
00:12:24,078 --> 00:12:28,002
我们是在内存的stack部分创建它

329
00:12:28,002 --> 00:12:31,017
我会在以后的视频中介绍stack和heap

330
00:12:31,017 --> 00:12:36,060
如果我做了那个视频的话，本视频上可能会有标记，所以到时候如果你想了解请前去查看

331
00:12:36,069 --> 00:12:39,048
但我也可以做的是，在heap上创建一个变量

332
00:12:39,048 --> 00:12:41,061
或者，我们可以问我们的电脑

333
00:12:41,061 --> 00:12:42,021
"嘿

334
00:12:42,021 --> 00:12:44,061
我想要你为我分配一些内存

335
00:12:44,061 --> 00:12:46,041
而且我想它是一个特定的尺寸”

336
00:12:46,041 --> 00:12:49,050
所以我可以做的就是，使用char*

337
00:12:49,050 --> 00:12:53,040
我们知道,char是一个字节，对吧

338
00:12:53,040 --> 00:12:55,011
所以当我问这样的问题时

339
00:12:55,011 --> 00:12:59,020
我管它叫buffer（缓冲缓存的意思），然后把它设为大小为8的new char[]

340
00:12:59,022 --> 00:13:02,013
这里我真正问它要的是8个字节的内存

341
00:13:02,013 --> 00:13:09,090
因此，这为我们分配了8个字节的内存，并返回一个指向这块内存的开始地址的指针

342
00:13:09,090 --> 00:13:12,006
然后我就可以使用一个叫memset的函数

343
00:13:12,006 --> 00:13:15,054
它就是用我们指定的数据填充一块内存

344
00:13:15,054 --> 00:13:20,037
它接受一个指针，该指针指向这块内存的开始处

345
00:13:20,037 --> 00:13:23,085
然后接受一个值，比如0，然后是大小

346
00:13:23,085 --> 00:13:26,028
就是应该填充多少个字节，在我们这

347
00:13:26,028 --> 00:13:28,026
我们知道我们有8个字节

348
00:13:28,026 --> 00:13:29,061
让我们运行这个程序

349
00:13:29,061 --> 00:13:30,072
我现在要把这个。。

350
00:13:30,072 --> 00:13:35,016
你会看到在这里有它的内存地址，不过你已经知道memory窗口是如何工作的以及所有这些，我就不罗嗦了

351
00:13:35,016 --> 00:13:38,064
所以我将在这里输入buffer这个变量，然后回车

352
00:13:38,064 --> 00:13:39,090
你会看到，看这里

353
00:13:39,090 --> 00:13:42,000
我们拿到了8个字节的内存，当然了，是连续的

354
00:13:42,009 --> 00:13:43,032
它们都被设为了0

355
00:13:43,032 --> 00:13:48,066
因为这就我们用memset做到的，是我们在这个例子中，由于我们使用了new这个关键字，所以该数据是分配在heap上的

356
00:13:48,066 --> 00:13:51,021
我们还应该在处理完后删除这个数据

357
00:13:51,021 --> 00:13:53,010
我们可以通过打delete[]来实现（译者按：话说他没有解释new和delete到底是如何实现的，我在评论里解释了下）

358
00:13:53,010 --> 00:13:54,003
我们知道它是一个array

359
00:13:54,003 --> 00:13:56,037
我们使用的是new[]来分配的

360
00:13:56,037 --> 00:14:03,060
所以我们应该使用delele[]来删除，如果我们够nice的话

361
00:14:03,060 --> 00:14:05,016
然而，不管怎样这个程序都会在这里结束

362
00:14:05,016 --> 00:14:08,091
这个例子的目的是再次重申，这是一个指针

363
00:14:08,091 --> 00:14:11,064
我们在这里说过，我们想分配8个char

364
00:14:11,064 --> 00:14:12,084
char是一个字节

365
00:14:12,084 --> 00:14:17,097
因此我们分配了8个字节，然后我们把这块内存的开始地址存在一个指针里

366
00:14:17,097 --> 00:14:22,041
还有一件事我想说的是，指针本身也只是变量

367
00:14:22,041 --> 00:14:25,086
这些指针-这些变量也存储在内存中

368
00:14:25,086 --> 00:14:30,072
但这就是我们可以有double pointers, triple pointers之类的骚操作，其实就是指针的指针

369
00:14:30,072 --> 00:14:32,004
那那些都是怎么工作的呢

370
00:14:32,004 --> 00:14:32,043
嗯

371
00:14:32,043 --> 00:14:37,071
你只要再下一层，就是说我现在有一个指针，它指向另一个指针

372
00:14:37,071 --> 00:14:40,062
所以现在我有一个变量，存储着一个内存地址

373
00:14:40,062 --> 00:14:43,062
它指向另一个变量，那个变量也存储着一个内存地址

374
00:14:44,061 --> 00:14:47,055
很简单，对吧，所以在我们例子中，用我们的buffer

375
00:14:47,055 --> 00:14:49,014
我可以创建一个double pointer

376
00:14:49,014 --> 00:14:49,038
对吧

377
00:14:49,038 --> 00:14:56,046
这个的意思是它是一个指针的指针，我给它取名叫ptr，并将它设为buffer的内存地址

378
00:14:56,046 --> 00:14:59,049
这时候就比较有意思了

379
00:14:59,049 --> 00:15:03,021
我将在把这个断点往上移动到这，因为我还不想删除数据

380
00:15:03,021 --> 00:15:04,056
让我们慢慢地看一看它

381
00:15:04,056 --> 00:15:08,055
这是指针的值，我要把它复制到这里

382
00:15:08,055 --> 00:15:09,063
现在

383
00:15:09,063 --> 00:15:15,009
你可以看到我们这里有b8 f1 02 00，4个字节

384
00:15:15,009 --> 00:15:20,090
我知道这个指针将是4字节，因为我在运行一个32位的应用程序

385
00:15:20,091 --> 00:15:22,068
在一个32位程序里

386
00:15:22,068 --> 00:15:26,025
一个内存地址是32位，更多关于这个的，以后的视频再说

387
00:15:26,025 --> 00:15:29,080
因为这台电脑的endianness其实是逆序的（译者按：所谓little endian）

388
00:15:29,080 --> 00:15:38,010
如果我复制它到这里，我们其实需要重新排列一下它，像这样，00 02 f1 b8 

389
00:15:38,010 --> 00:15:40,000
如果我按回车

390
00:15:40,005 --> 00:15:40,062
看啊

391
00:15:40,062 --> 00:15:45,012
我被带到储存了这些0的buffer的内存位置

392
00:15:45,012 --> 00:15:46,041
好的

393
00:15:46,041 --> 00:15:47,031
就是这样了

394
00:15:47,031 --> 00:15:48,060
指针的指针

395
00:15:48,060 --> 00:15:49,077
解决了

396
00:15:49,077 --> 00:15:50,082
非常简单的东西

397
00:15:50,082 --> 00:15:51,072
就是这样

398
00:15:51,072 --> 00:15:53,046
我可以一整天讲这些

399
00:15:53,046 --> 00:15:54,018
但讲真

400
00:15:54,018 --> 00:15:59,010
我肯定会到头来说指针只是一个存储着内存地址的整数

401
00:15:59,010 --> 00:16:01,086
这就是它的全部，烙在脑子里！

402
00:16:01,086 --> 00:16:08,010
我将会制作更多关于这个话题的视频，以及处理像指针算术之类的以及更高级的指针操作

403
00:16:08,013 --> 00:16:09,033
如果你是新来到这个频道

404
00:16:09,033 --> 00:16:10,044
欢迎订阅

405
00:16:10,044 --> 00:16:12,027
当您开始使用指针时

406
00:16:12,027 --> 00:16:15,000
当我们开始在这个系列中使用指针时

407
00:16:15,000 --> 00:16:18,054
你会得到更多的例子，你会发现它们有多强大，以及我们可以用它们干嘛

408
00:16:18,054 --> 00:16:20,097
但这是它们的原理

409
00:16:20,097 --> 00:16:23,040
不要过度思考

410
00:16:23,040 --> 00:16:24,063
它们真的很简单

411
00:16:24,063 --> 00:16:25,028
谢谢收看

412
00:16:25,028 --> 00:16:26,043
我希望你喜欢这个视频

413
00:16:26,043 --> 00:16:30,081
如果你喜欢，请点赞，你也可以在Twitter和Instagram上关注我

414
00:16:30,081 --> 00:16:34,044
如果你真的喜欢这个视频，你想看更多这样的视频

415
00:16:34,044 --> 00:16:35,061
你可以在patreon上支持我

416
00:16:37,044 --> 00:16:41,010
下节课我们会讲到reference，下个视频再见

417
00:16:41,010 --> 00:16:41,043
再见

