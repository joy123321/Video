1
00:00:00,007 --> 00:00:03,005
大家好我是cherno，欢迎回到我的c++系列

2
00:00:03,021 --> 00:00:07,015
今天我们将要学到编译器是怎么工作的

3
00:00:07,015 --> 00:00:12,002
我们退后一步，想一下大的蓝图是什么

4
00:00:12,024 --> 00:00:14,016
c++编译器到底负责什么

5
00:00:14,016 --> 00:00:19,020
我们用文本来写c++，就是文本(text)而已

6
00:00:19,040 --> 00:00:25,000
我们需要某种方法将文本转化成应用，从而在计算机运行

7
00:00:25,008 --> 00:00:32,022
从text到可执行binary，基本上有两个主要操作需要发生

8
00:00:32,035 --> 00:00:35,028
一个是compiling(编译)，一个是linking（链接）

9
00:00:35,045 --> 00:00:43,072
本视频我们只讨论compiling，我另有一个专门的视频讲linking，你可能也需要去看看，连接在下方描述里

10
00:00:44,005 --> 00:00:53,042
所以，c++编译器唯一要做的就是把文本变为中继格式——obj

11
00:00:53,062 --> 00:00:57,018
然后obj们会传入linker，linker会做所有linking的事

12
00:00:57,018 --> 00:01:02,097
总之，我们在谈compiling，在compiler产出这些obj时，其实它有做好几件事

13
00:01:02,097 --> 00:01:09,085
首先，它需要pre-process（预处理）我们的代码，也就是所有preprocessor语句会在那时被评估

14
00:01:09,088 --> 00:01:14,045
被预处理后，我们会进入tokenizing(标记解释)和parsing（解析）阶段

15
00:01:14,055 --> 00:01:21,065
基本就是把这"英文"C++文本处理成编译器能懂和处理的语言

16
00:01:21,070 --> 00:01:29,055
基本上结果就是创建某种叫做abstract syntax tree（抽象语法树），也就是我们代码的表达，但是是以抽象语法树的形式

17
00:01:29,055 --> 00:01:37,053
说到底编译器的工作也就是把代码转化成要么是constant data（常数资料），要么是instructions（指令）

18
00:01:37,078 --> 00:01:47,072
当编译器创建了这颗抽象语法树后，就可以开始产生代码了，这个代码是真正的cpu会执行的机器码

19
00:01:47,082 --> 00:01:53,000
同时，我们也会得到一些其他数据，比如某个地方存储着我们所有的constant variables(常数变量)

20
00:01:53,000 --> 00:02:01,010
这基本就是编译器的工作了，并不非常复杂，当然你的代码越来越复杂它也越来越复杂

21
00:02:01,045 --> 00:02:11,030
但这就是它的要点了，我们将继续深究，看看每个阶段具体都在做什么，好让你们弄懂

22
00:02:11,030 --> 00:02:17,040
这里，我们这个简单的hello world程序，之前在关于c++工作原理的视频写的

23
00:02:17,052 --> 00:02:24,065
我们有这个main函数，调用了被定义在log.cpp里的log函数，它仅仅打印我们的message到屏幕

24
00:02:24,085 --> 00:02:28,005
这就是我们的简单程序——打印hello world了

25
00:02:28,012 --> 00:02:32,048
如果我们进入output目录，debug下你可以看到它生成了一个exe

26
00:02:32,048 --> 00:02:38,065
回到项目目录，debug下它生成了main.obj,log.obj，

27
00:02:38,090 --> 00:02:44,027
也就是编译器给每个cpp，也就是每个translation unit，生成了obj

28
00:02:44,038 --> 00:02:57,020
项目里的每个cpp，都会被编译器编译成一个obj，这些cpp文件也叫translation unity（编译单元）

29
00:02:57,020 --> 00:03:04,027
本质上你得意识到c++根本不在乎文件，文件这种东西在c++里不存在

30
00:03:04,027 --> 00:03:10,050
举例说，java里，你的class(类)名必须跟文件名相同，而你的文件夹结构也得跟package一样

31
00:03:10,056 --> 00:03:15,090
之所以如此是因为java需要某些文件存在，c++完全不是这回事

32
00:03:15,098 --> 00:03:22,015
没有文件这种东西，文件只是用来给编译器提供源码的某种方法

33
00:03:22,025 --> 00:03:27,070
你需要告诉编译器文件类型和编译器该如何处理它

34
00:03:27,075 --> 00:03:37,052
当然，你建个.cpp文件，编译器就会把它当c++文件，同样的，如果我建个.c文件或者.h

35
00:03:37,065 --> 00:03:44,025
它会把它.c当c file，而非c++文件.h当header file

36
00:03:44,036 --> 00:03:47,082
这些只是默认的既成习惯，你可以改变它们

37
00:03:47,098 --> 00:03:52,000
这只是说如果你不告诉编译器怎么处理，编译器就会这么处理它们

38
00:03:52,015 --> 00:03:56,023
我可以去新建个.cherno文件让编译器去编译，完全没问题

39
00:03:56,038 --> 00:04:01,077
只要我告诉编译器这是个c++文件，请按c++编译

40
00:04:02,015 --> 00:04:07,032
你只要记住，文件不代表任何东西，记住哈，很重要

41
00:04:07,032 --> 00:04:13,056
话说回来，我们传给编译器的每个c++文件，我们告诉它这是c++，请按c++编译

42
00:04:13,056 --> 00:04:18,025
它就会把它当成一个translation unit，然后translation unit会得到一个obj

43
00:04:18,027 --> 00:04:23,065
在cpp文件include其他cpp有时候其实是很常见的作法

44
00:04:23,065 --> 00:04:27,045
基本上就是创建一个大的cpp文件，里面有很多cpp文件

45
00:04:27,052 --> 00:04:34,085
然后你只编译那一个cpp文件，也就是只有一个translation unit，也就只有一个obj

46
00:04:34,092 --> 00:04:40,098
这也就是为啥会有这两个术语，一个是translation unit，一个是cpp文件

47
00:04:41,005 --> 00:04:44,060
因为一个cpp不一定等于一个translation unit

48
00:04:44,075 --> 00:04:48,088
但如果你的项目里都是独立的cpp文件，从来不互相include的话

49
00:04:48,098 --> 00:04:54,092
那每个cpp就是一个translation unit，每个也会产生一个obj

50
00:04:55,012 --> 00:04:59,027
这两个其实挺大的，你看一个是30kb一个是46kb

51
00:04:59,038 --> 00:05:03,060
之所以如此是因为我们include了iostream，它里面有相当多东西

52
00:05:03,067 --> 00:05:09,048
这就是为啥我们的文件这么大了，它们其实很复杂，所以在我们去看它们里面到底有啥之前

53
00:05:09,060 --> 00:05:19,020
我们创建一个比较简单点的，我现在右击source file，选add new item->cpp，取名math.cpp

54
00:05:19,030 --> 00:05:23,092
这里我们就写个简单的乘法函数，就是两数相乘

55
00:05:23,098 --> 00:05:28,077
我不打算include任何东西，就是一个简单的函数

56
00:05:28,080 --> 00:05:44,067
它会返回一个整数，函数名叫multiply，有两个参数int a和b，然后新建一个叫result的变量，存放axb的结果，然后返回这个结果，很简单

57
00:05:44,069 --> 00:05:48,098
我们按control+F7来build该文件，你看这里，build好了

58
00:05:49,008 --> 00:05:54,077
实际上我要把vs的字体放大一点，你们好看见，现在你可以看到output窗口了

59
00:05:54,083 --> 00:06:00,035
如果我们回到output目录，你会看到我们有了这个math.obj，只有4kb

60
00:06:00,038 --> 00:06:06,061
在我们查看这个文件到底有什么之前，我们来讲一下之前提到的编译第一阶段

61
00:06:06,061 --> 00:06:13,092
————preprocessing，在这期间，编译器就是检查所有pre-processing语句并评估

62
00:06:14,015 --> 00:06:18,023
常见的有include, define, if和ifdef

63
00:06:18,023 --> 00:06:22,057
它们同样也是pragma语句，就是告诉编译器具体要做什么，不过今后视频再说

64
00:06:22,070 --> 00:06:28,040
那我们来看看我们这边最常见的preprocessor语句，#include，到底是如何工作的

65
00:06:28,048 --> 00:06:33,020
#include其实非常简单，你只要指定你要include哪个文件

66
00:06:33,020 --> 00:06:38,095
然后preprocessor会打开该文件，读取所有内容，然后粘贴进你写include的那个文档

67
00:06:38,095 --> 00:06:44,042
这就是全部了，非常非常简单，现在我将证明它有多简单

68
00:06:44,052 --> 00:06:51,095
回到这里，我来创建一个header文档，右击，add，new item, header file,我们命名它EndBrace，添加

69
00:06:52,010 --> 00:07:02,012
我们删除它里面的内容，然后就打一个 "}"（closing curly brace)，仅此而已

70
00:07:02,017 --> 00:07:08,063
回到math.cpp，你可以看到我们为Multiply函数写了一个"}"

71
00:07:08,063 --> 00:07:11,080
我们把它删掉，如果我们现在按ctrl+F7编译

72
00:07:11,090 --> 00:07:17,080
编译器会提示左大括号(left curly brace)在文件的最后没有对应的括号

73
00:07:17,080 --> 00:07:24,050
我们就不像正常人一样更正它加个括号，而是去include我们的EndBrace.h

74
00:07:24,050 --> 00:07:31,090
输入#include "EndBrace.h"，就行了，按ctrl+F7来编译

75
00:07:32,000 --> 00:07:37,094
成功了，当然会成功了，因为编译器所做的就是打开这个文档

76
00:07:37,094 --> 00:07:44,040
把里面的所有内容copy到这，仅此而已

77
00:07:44,040 --> 00:07:49,033
header文件解决了，你现在应该完全明白了如何应用它了

78
00:07:49,033 --> 00:07:56,033
其实有办法让编译器输出一个文档，里面包含所有这些preprocessor评估的结果

79
00:07:56,033 --> 00:08:01,073
如果我们恢复include "endbrace.h"，然后右击项目，点properties

80
00:08:01,073 --> 00:08:07,090
在C++底下，选Preprocessor，将preprocessor to a file改成yes

81
00:08:07,090 --> 00:08:12,035
确保你改的是你目前所应用的configuration和platform，以免改动不生效

82
00:08:12,035 --> 00:08:16,055
点ok，然后ctrl+F7重新build

83
00:08:16,055 --> 00:08:23,024
打开output目录，你可以看到这个新的".i"文档，也就是预处理过的c++代码

84
00:08:23,024 --> 00:08:26,005
在文本编辑器里打开它，看看里面有什么

85
00:08:26,010 --> 00:08:28,088
ok，可以看到preprocessor到底生产了啥

86
00:08:28,088 --> 00:08:37,078
我们源码里有这句include endbrace，而preprocessor代码里只是将.h里的“}”插进来了

87
00:08:37,092 --> 00:08:43,025
挺简单的东西，我们来添加更多的preprocessor语句，来看看它都做什么

88
00:08:43,038 --> 00:08:48,009
回到文件，我先恢复括号，因为看着那个include有点烦

89
00:08:48,009 --> 00:08:54,017
在这上面，我要define一些东西，我们将define INTEGER 作为int

90
00:08:54,020 --> 00:08:57,072
永远别问我为什么要这么做，这只是个例子

91
00:08:57,083 --> 00:09:03,015
define这个预处理语句就是会去搜索这个词，然后替换成后面的东西

92
00:09:03,025 --> 00:09:14,045
所以我把int改成Integer，这里也一样，按ctrl+F7，回到这个文件，看发生了什么

93
00:09:14,045 --> 00:09:22,008
看起来一如平常，如果我们在这干点蠢事，比如说改成cherno，按ctrlF7

94
00:09:22,014 --> 00:09:26,033
回到文件，它上面写着cherno multiply和cherno result

95
00:09:26,033 --> 00:09:34,010
挺酷的，我们继续玩一玩，我们恢复int，删掉define

96
00:09:34,010 --> 00:09:43,022
相反的，我要用一个叫if的东西，if预处理语句可以让我们依据特定条件包含或者剔除代码

97
00:09:43,030 --> 00:09:52,098
在这里写if 1，也就是true，后面加#endif，ctrl+F7，回到预处理过的文件

98
00:09:52,098 --> 00:09:59,020
可以看到跟之前没有if语句一模一样，如果回到这边改成if 0

99
00:09:59,030 --> 00:10:06,010
vs会将我们的代码变成灰色，也就是禁用状态，按ctrl+F7再来看.i文件，里面没有代码

100
00:10:06,017 --> 00:10:10,035
这是另一个关于预处理语句的好例子。最后一个，来看看include

101
00:10:10,035 --> 00:10:18,078
我们删掉if 0，然后写include iostream，巨大巨大的iostream

102
00:10:18,099 --> 00:10:28,053
按ctrl+F7，回到这边，wow，看看它，我们这里有50,623行

103
00:10:28,053 --> 00:10:33,085
我们的函数在最底下，看，这么多都是include iostream干的

104
00:10:33,085 --> 00:10:39,078
当然了，iostream也会include其他文件，就跟从山上往下滚雪球一样

105
00:10:39,078 --> 00:10:45,009
你现在可以知道为什么那些obj那么大了，因为include了iostream，那是相当多的代码

106
00:10:45,009 --> 00:10:53,020
ok，好了， 这就是preprocessor了，当它结束后，我们就可以将c++代码编译成机器码了

107
00:10:53,020 --> 00:10:57,048
如果我们回到项目，我们先删掉这句include，因为我们不需要

108
00:10:57,048 --> 00:11:01,028
按ctrl+F7,你会看到preprocessor文件回到正常了

109
00:11:01,028 --> 00:11:06,060
实际上，我要去hello world项目，点properties，禁用preprocessor to a file

110
00:11:06,060 --> 00:11:12,003
如果你看一眼preprocessor to a file会做什么，会发现它其实就不产生obj了

111
00:11:12,003 --> 00:11:18,051
所以我们得禁用它，从而build我们的项目，点ok，按ctrl+F7build cpp文件

112
00:11:18,051 --> 00:11:23,010
你可以看到我们得到了更新后的math.obj

113
00:11:23,010 --> 00:11:26,010
我们来看看obj文件里到底有什么

114
00:11:26,017 --> 00:11:30,084
如果我们用文本编辑器打开它，会发现是二进制，看不出名堂

115
00:11:30,084 --> 00:11:37,026
但其中的一部分就是我们这个multiply函数在被调用时，cpu会运行的机器码

116
00:11:37,026 --> 00:11:43,085
由于这是二进制，而且完全不可读，我们来将它转换成一种稍微可读一点的格式

117
00:11:43,085 --> 00:11:47,010
有几种方法可以实现，但我就打算用vs

118
00:11:47,010 --> 00:11:51,045
右击hello world，点properties，在c/c++下，output files

119
00:11:51,045 --> 00:11:58,038
我将assembla output设置为assembly-only listing，点ok，按ctrl+F7

120
00:11:58,038 --> 00:12:02,050
在output目录下，你应该可以看到一个math.asm文件

121
00:12:02,053 --> 00:12:08,070
我们用一个文本编辑器打开它，这基本就是刚才那个obj所包含内容的一个可读版本

122
00:12:08,070 --> 00:12:15,010
如果我们下拉到这里，会看到这个叫multiply的函数，然后有一堆汇编指令

123
00:12:15,010 --> 00:12:18,092
这些是我们运行函数时cpu会执行的真正指令

124
00:12:18,092 --> 00:12:24,017
我目前不打算细讲所有这些汇编代码，也许之后会出一个视频讲

125
00:12:24,017 --> 00:12:28,067
但如果你看这边，我们的乘法运算其实发生在这里

126
00:12:28,067 --> 00:12:37,092
基本上就是，我们载入变量a到eax寄存器（register），然后在b和a上执行一个imul指令也就是乘法指令

127
00:12:38,008 --> 00:12:43,000
然后把结果存放在一个叫result的变量，并把它move回eax并返回它

128
00:12:43,000 --> 00:12:50,078
之所以有两次move是因为我其实有创造一个叫result的变量然后再返回它，而非直接返回a * b

129
00:12:50,095 --> 00:12:57,003
这就是为啥先会把eax move到result，然后又把result move回eax

130
00:12:57,025 --> 00:13:03,017
而这是完全不必要的，这是另一个非常好的例子来显示如果你设置编译器不要优化，那么你将获得运行缓慢的代码

131
00:13:03,036 --> 00:13:05,084
因为它在做这种毫无道理的事情

132
00:13:05,084 --> 00:13:11,062
如果我回到代码把这个result变量删掉，而直接返回a*b，然后编译

133
00:13:11,069 --> 00:13:18,065
你会看到汇编码有点不一样了，因为我们只是在b和eax上做一个imul而已

134
00:13:18,065 --> 00:13:21,030
eax其实会存放我们要返回的值

135
00:13:21,040 --> 00:13:25,028
现在，所有这些看起来像是很多代码，这是因为我们在debug环境下编译

136
00:13:25,040 --> 00:13:32,065
而debug是不会做任何优化的，而且会有很多额外的东西，以确保我们的代码尽可能冗长以及尽可能易于debug

137
00:13:32,065 --> 00:13:41,018
如果我们回到项目，右击->properties，来optimization这里，在debug配置下

138
00:13:41,018 --> 00:13:46,028
选择maximize speed，如果我们现在再来编译，会得到一个错误~

139
00:13:46,047 --> 00:13:53,015
因为可以看到O2和RTC其实是不兼容的，所以我们得回到这里，进入code generation

140
00:13:53,015 --> 00:13:58,022
确保basic runtime checks设置为default，也就是不会运行行时检查(runtime checks)

141
00:13:58,030 --> 00:14:01,055
其实就是编译器会插入的一些代码来帮助我们debugging

142
00:14:01,055 --> 00:14:06,035
按ctrl+F7，再来看汇编文件，wow，看起来小了很多

143
00:14:06,042 --> 00:14:11,060
我们基本上就是把变量载入一个寄存器，然后做乘法，仅此而已

144
00:14:11,078 --> 00:14:18,060
挺简单的东西，你现在应该对编译器优化有个大概的概念了

145
00:14:18,065 --> 00:14:22,001
这只是个简单的例子，我们来看看稍微高级点的

146
00:14:22,001 --> 00:14:29,063
我们来个不一样的例子，在这里我们不接受任何参数，但我决定写比如说5*2

147
00:14:29,063 --> 00:14:36,090
保存一下，然后去properties确认我禁用了优化，再次编译并查看文件

148
00:14:37,010 --> 00:14:45,070
可以看到它所做的也很简单，只是move 10到eax寄存器，也就是会存放返回值的寄存器

149
00:14:45,078 --> 00:14:51,053
再看看我们的代码，就是直接把5*2简化成了10

150
00:14:51,065 --> 00:14:59,035
因为没有必要对5*2两个常数去在运行时计算，这就是所谓的constant folding(常量折叠)

151
00:14:59,060 --> 00:15:03,035
也就是任何常量都可以在编译时计算出来

152
00:15:03,053 --> 00:15:06,072
让我们添加一个函数，让事情变得更有意思

153
00:15:06,080 --> 00:15:12,028
比如，我将写一个log函数，它会log一条信息

154
00:15:12,028 --> 00:15:19,008
当然我没打算真的log任何东西，因为那样还得include iostream，那会极大复杂化本例子

155
00:15:19,008 --> 00:15:25,055
我就让它返回这条传进来的信息，在multiply里，调用log

156
00:15:25,055 --> 00:15:37,015
这里改回a, b，返回a*b,按ctrl+F7,ok，来看看编译器生成了什么

157
00:15:37,015 --> 00:15:44,034
往下拉一些，可以看到这个log函数，并没有真的做什么，只是返回message

158
00:15:44,034 --> 00:15:49,078
可以看到它在把message指针move到eax，也就是我们讲过到返回寄存器

159
00:15:49,086 --> 00:15:53,053
这是log函数，往上翻一点，可以看到multiply函数

160
00:15:53,060 --> 00:16:03,050
这里主要就是在我们做乘法之前call（调用) log

161
00:16:03,075 --> 00:16:09,067
你可能会好奇为什么这个log函数会被装饰成带有随机字符和@符号的样子

162
00:16:09,067 --> 00:16:14,003
这其实是函数签名，它需要独一无二的定义你的函数

163
00:16:14,003 --> 00:16:20,075
我们会在linking视频中更多的讲它，但根本上，当我们有多个obj，我们的函数会在多个obj中被定义

164
00:16:20,075 --> 00:16:26,070
linker会负责将它们联系起来，它怎么做呢，就是会查找这个函数签名

165
00:16:26,075 --> 00:16:30,008
你现在要知道的就是我们在调用这个log函数

166
00:16:30,017 --> 00:16:34,025
当你调用函数时，编译器就会生成一个call指令

167
00:16:34,038 --> 00:16:43,025
我们这种情况，可能有点蠢，我们都没存放返回值，基本上会被优化很多

168
00:16:43,038 --> 00:16:53,005
如果我们回到这打开优化到最大速度，编译，你会看到它完全消失了

169
00:16:53,015 --> 00:16:57,097
是的，编译器看它什么也没做，就决定移除这段代码

170
00:16:57,097 --> 00:17:07,045
但现在你应该基本上了解了编译器是怎么工作的了，它会拿到源文件，生成一个包含机器语言的和其他一些我们定义的常数数据的obj文件

171
00:17:07,045 --> 00:17:08,070
就是这些

172
00:17:08,070 --> 00:17:15,003
我们拿到这些obj文件之后，我们可以将他们链接为一个包含所有我们需要运行的机器代码的可执行文件

173
00:17:15,007 --> 00:17:17,005
这就是我们怎么利用c++来实现一个程序

174
00:17:17,005 --> 00:17:18,035
很简单

175
00:17:22,035 --> 00:17:23,073
enjoyed this video hope you learned

176
00:17:23,073 --> 00:17:25,008
something new you should now have a

177
00:17:25,008 --> 00:17:26,052
basic understanding of what the simple

178
00:17:26,052 --> 00:17:27,078
of compiler actually

179
00:17:27,078 --> 00:17:29,016
and that's going to be really important

180
00:17:29,016 --> 00:17:30,087
when it comes to debugging and also when

181
00:17:30,087 --> 00:17:32,034
we get into more advanced topics in the

182
00:17:32,034 --> 00:17:33,060
future make sure you follow me on

183
00:17:33,060 --> 00:17:35,061
Twitter and Instagram and if you really

184
00:17:35,061 --> 00:17:37,017
like this you can support me on patreon

185
00:17:37,017 --> 00:17:38,082
I'll see you guys next time goodbye

186
00:17:38,082 --> 00:17:41,048
warm

