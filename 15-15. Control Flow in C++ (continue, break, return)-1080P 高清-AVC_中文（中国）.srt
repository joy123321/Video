1
00:00:00,000 --> 00:00:01,088
大家好， 我是cherno

2
00:00:01,088 --> 00:00:04,032
欢迎大家收看C++系列的视频

3
00:00:04,032 --> 00:00:06,062
今天我们要来讲一讲有关控制流语句的知识

4
00:00:06,062 --> 00:00:09,040
这是上一期视频的接续

5
00:00:09,040 --> 00:00:12,018
如果你们还没看过上周那期关于循环的视频

6
00:00:12,018 --> 00:00:13,018
你们快去看看那期视频

7
00:00:13,018 --> 00:00:14,015
链接应该就在页面的附近

8
00:00:14,015 --> 00:00:16,092
控制流语句通常是和循环一起使用的

9
00:00:16,092 --> 00:00:21,023
也就是说，它让我们可以更好地控制循环了

10
00:00:21,023 --> 00:00:26,023
有三个主要的控制流语句 Continue\break\return 

11
00:00:26,023 --> 00:00:27,075
它们的功能有所不同

12
00:00:27,075 --> 00:00:30,000
continue只能用在循环内部

13
00:00:30,000 --> 00:00:36,097
简单来说continue的意思是：如果还能进行迭代的话 直接进行下一次的迭代.否则，就会结束循环。

14
00:00:36,097 --> 00:00:41,020
break主要是用在循环里的 但是它也经常出现在switch语句中

15
00:00:41,020 --> 00:00:44,040
它的功能是，直接跳出循环

16
00:00:44,040 --> 00:00:50,022
最后，return可以说是功能最强大的一个了

17
00:00:50,022 --> 00:00:53,012
因为return会直接完全地退出函数

18
00:00:53,012 --> 00:00:56,055
如果你在函数内 执行到了return命令

19
00:00:56,055 --> 00:00:58,010
你会直接退出这个函数

20
00:00:58,010 --> 00:01:00,055
这个函数当然也需要一个返回值

21
00:01:00,055 --> 00:01:02,072
当你输入了return 你的上下文(context)就会自动返回

22
00:01:02,072 --> 00:01:04,060
只有yoid是可以直接用return的

23
00:01:04,060 --> 00:01:08,090
如果你的函数需要返回值 你在输入return的时候就必须要提供值

24
00:01:08,090 --> 00:01:12,043
别的不多说了 直接来看看我们的例子

25
00:01:12,043 --> 00:01:16,090
这是我们上期视频留下来的程序 直接运行它

26
00:01:16,090 --> 00:01:18,090
你会看到在屏幕上输出了很多次的hello world

27
00:01:18,090 --> 00:01:22,072
下面还有两个没有包含内容的while循环 和do-while循环

28
00:01:22,072 --> 00:01:24,082
我可以把他们直接删除 因为我们根本不需要他们

29
00:01:24,085 --> 00:01:29,030
我会从上次的程序中保存下来的东西只有只有这个for循环

30
00:01:29,030 --> 00:01:32,022
第一个上场的控制流语句是 continue

31
00:01:32,022 --> 00:01:35,020
continue语句会让我们直接跳到下一个循环的迭代

32
00:01:35,020 --> 00:01:41,065
如果我们在这儿写了continue 这根本不会影响到循环

33
00:01:41,065 --> 00:01:44,022
因为这已经是在循环的最后

34
00:01:44,022 --> 00:01:47,045
到了这行之后就直接进行下一次的循环

35
00:01:47,045 --> 00:01:49,053
这并不能修改循环的工作

36
00:01:49,053 --> 00:01:57,007
如果我输入if(i%2==0) continue;

37
00:01:57,007 --> 00:02:01,015
然后再运行我的程序 你就会看见

38
00:02:01,015 --> 00:02:04,075
发生的是它跳过了从第一次之后，每个第二次的迭代

39
00:02:04,075 --> 00:02:09,075
为了更好地说明发生了什么 我们在这引入数字

40
00:02:09,075 --> 00:02:14,075
所以我让程序不仅输入hello world 还输出每次循环 i的值

41
00:02:14,075 --> 00:02:20,060
如果我这么写 按F5你可以看到我们的hello world只在奇数次的迭代中

42
00:02:20,060 --> 00:02:23,050
也就是说当i为0时 就不会输出hello world

43
00:02:23,050 --> 00:02:25,050
因为0对2求余结果是0

44
00:02:25,050 --> 00:02:28,043
if后的语句就为真 就执行continue操作

45
00:02:28,043 --> 00:02:31,000
当i等于1时 我们就要执行log函数了

46
00:02:31,000 --> 00:02:32,000
当i等于2时 不执行

47
00:02:32,000 --> 00:02:33,077
当i等于3时 我们又要执行log函数了

48
00:02:33,077 --> 00:02:35,023
当i等于4时 不执行

49
00:02:35,023 --> 00:02:36,050
当然i等于5的情况不用考虑

50
00:02:36,050 --> 00:02:39,005
因为当i等于5时，我们就跳出了这个for循环

51
00:02:39,005 --> 00:02:42,020
因为这句，说明i必须小于5

52
00:02:42,020 --> 00:02:47,020
我们可以把这个条件改得稍微简单一点 比如 if(i>2)

53
00:02:47,020 --> 00:02:49,095
所以在这个情况下，应该发生的是

54
00:02:49,095 --> 00:02:55,085
当i是0、1或者是2时 log函数还有，在那次迭代的情况下i的数值就应该被打印出来

55
00:02:55,085 --> 00:02:58,055
然而当i是3或者4的时候 就不会有这种情况

56
00:02:58,055 --> 00:03:01,045
如果我们运行这个程序 你可以看到 三次的hello world

57
00:03:01,045 --> 00:03:03,068
对于continue已经讲得足够多了

58
00:03:03,068 --> 00:03:08,068
我的意思是 只要运行到continue 就开始了下一次循环的迭代

59
00:03:08,068 --> 00:03:10,048
在第8行放置一个断点来debug这段代码

60
00:03:10,048 --> 00:03:11,082
这能让你了解得更深入

61
00:03:11,082 --> 00:03:15,007
所以你可以看到 在这 i等于0 所以不会触发 continue

62
00:03:15,007 --> 00:03:17,088
所以就继续往下走去执行log

63
00:03:17,088 --> 00:03:20,038
当i等于1和i等于2时都是一样的

64
00:03:20,038 --> 00:03:25,038
当i等于3时，3>2我们就要执行continue

65
00:03:25,038 --> 00:03:28,030
这意味着如果我现在按下F10 它不会向下去执行Log

66
00:03:28,030 --> 00:03:33,030
你可以看到它直接跳转回到开始的地方，然后它会执行i++

67
00:03:33,030 --> 00:03:36,020
再判断循环条件 然后再跳回到这里

68
00:03:36,020 --> 00:03:38,038
在本例中，现在将会执行一模一样的操作

69
00:03:40,052 --> 00:03:42,018
我们现在来看一下break

70
00:03:42,018 --> 00:03:45,012
如果我现在就仅仅是把这个continue改成break

71
00:03:45,012 --> 00:03:46,070
还是会得到和前面一样的结果

72
00:03:46,070 --> 00:03:50,077
你可以看到  我们得到了0 1 2没有别的

73
00:03:50,077 --> 00:03:53,050
如果我们重新回到我们的第一个例子

74
00:03:53,050 --> 00:03:58,073
If(i%2==0)然后按F5，你可以看到现在什么也没得到

75
00:03:58,073 --> 00:04:01,018
举个稍微好一点的例子

76
00:04:01,018 --> 00:04:05,045
把条件改成if((i+1)%2==0)

77
00:04:05,045 --> 00:04:07,012
如果我现在再把它改回continue

78
00:04:07,012 --> 00:04:11,025
你可以看到现在得到的不是奇数 而是偶数

79
00:04:11,025 --> 00:04:13,018
而是偶数 所以现在我们输出了 0 2 4

80
00:04:13,018 --> 00:04:22,040
如果我现在把这个continue替换成break 就会发生 只打印了第一行 

81
00:04:22,040 --> 00:04:26,027
因为每当它运行到break的时候 意味着 循环结束了

82
00:04:26,027 --> 00:04:31,098
我们在这里设置断点，然后运行程序

83
00:04:31,098 --> 00:04:34,073
然后第一次运行时，这个条件不为真

84
00:04:34,073 --> 00:04:35,077
所以不运行break语句

85
00:04:35,077 --> 00:04:41,038
第二次循环的时候，我们就会运行到break语句 因为这次判断条件是真

86
00:04:41,038 --> 00:04:44,098
如果我现在按下F10我们就会马上跳出循环，跳到代码的下一行

87
00:04:44,098 --> 00:04:47,077
这就是break他会完全break掉我们的for循环

88
00:04:47,077 --> 00:04:51,050
当然这种在循环中的控制流语句适用于所有的循环

89
00:04:51,050 --> 00:04:54,080
所以for循环、while循环、do-while循环他们的工作原理是一样的

90
00:04:54,080 --> 00:04:58,005
好，最后一个是return

91
00:04:58,005 --> 00:05:02,012
这是一个需要整数作为返回值的函数

92
00:05:02,012 --> 00:05:04,083
所以我们可以输入return我们必须要返回一些东西

93
00:05:04,083 --> 00:05:09,040
我们可以试着这样写 然后按下F7 接着运行失败了

94
00:05:09,040 --> 00:05:13,067
因为，你可以看这，这里提醒我们main函数需要一个返回值

95
00:05:13,067 --> 00:05:16,057
因为声明的时候就已经做了规定

96
00:05:16,057 --> 00:05:18,062
所以我可以输入 return 0

97
00:05:18,062 --> 00:05:20,025
当然 0 是一个有效的整数

98
00:05:20,025 --> 00:05:25,090
如果我运行这段代码，在return处就会直接关闭我们的程序

99
00:05:25,090 --> 00:05:29,073
因为我的程序没有运行到 std::cin.get();这行代码

100
00:05:29,080 --> 00:05:32,040
这行代码可以保持运行窗口是打开的

101
00:05:32,040 --> 00:05:34,020
因为这行代码让电脑期待我们去提供输入

102
00:05:34,020 --> 00:05:36,085
所以我再次设置好断点然后运行我的程序

103
00:05:36,085 --> 00:05:41,012
你就可以看到 第一次，运行得很好，输出了hello，world

104
00:05:41,012 --> 00:05:47,052
第二次循环 当我运行到return 0；的时候直接就跳到了最后的}

105
00:05:47,052 --> 00:05:49,025
因为这个函数结束了

106
00:05:49,025 --> 00:05:56,035
还有一个关于return要注意的事项是，你不用像break和continue那样在循环内使用

107
00:05:56,035 --> 00:06:02,075
return可以被写在任何地方 所以我们可以写if(5>8) return0;

108
00:06:02,075 --> 00:06:06,012
在这里我必须提供一个值，因为这个函数需要返回一个整数

109
00:06:06,012 --> 00:06:10,085
所以return没必要在一个循环内，可以在代码的任何地方

110
00:06:10,085 --> 00:06:13,083
你甚至可以不要有if语句，你可以写成这样

111
00:06:13,083 --> 00:06:18,083
当然，在本例中最后一行代码在任何情况下都不会被运行

112
00:06:18,083 --> 00:06:20,020
所以这行就是一个”死“代码

113
00:06:20,020 --> 00:06:24,077
有些编译器，尤其是在其他编程语言的情况下，将会严格地限制你写这种代码

114
00:06:24,085 --> 00:06:27,090
因为在这种情况下，删除这行也没事，反正永远都不会被调用。

115
00:06:27,090 --> 00:06:30,062
关于控制流语句已经讲了足够多了

116
00:06:30,062 --> 00:06:33,095
return可以在任何地方使用 它会退出当前的函数

117
00:06:33,095 --> 00:06:39,040
当然，请你记住，如果你的函数需要返回一个值 那就必须要输入一个返回的值

118
00:06:39,040 --> 00:06:44,040
这些控制流语句就控制了 程序的运行

119
00:06:44,040 --> 00:06:50,065
这些循环、控制流、if语句就是逻辑编程的本质

120
00:06:50,065 --> 00:06:54,080
这些是你来控制程序运行的的工具

121
00:06:54,080 --> 00:06:57,035
比如 哪些语句接下来要执行之类的问题

122
00:06:57,035 --> 00:07:07,070
if语句、条件语句、循环、控制流语句是可以用来修改程序运行情况的唯一工具

123
00:07:07,070 --> 00:07:11,052
除非你想直接把地址写入指令指针(IP)，别这么做

124
00:07:11,052 --> 00:07:14,017
这个系列视频逐渐进行下去之后

125
00:07:14,017 --> 00:07:19,085
我可能会开始写一些应用，届时会经常使用到这些控制流语句

126
00:07:19,085 --> 00:07:22,067
到时候会给大家展示该在何处使用，还有如何去使用它

127
00:07:22,067 --> 00:07:28,042
也可能会给大家展示如何写代码不去用它，或者用别的语句来完成

128
00:07:28,042 --> 00:07:32,067
如果你想看到一些更有说明力的视频的话，就等着看我之后的视频吧

129
00:07:32,067 --> 00:07:37,035
当我们开始写真正的代码的时候，肯定会讲到包含这一块的事

130
00:07:37,035 --> 00:07:40,080
因为这些都是编写一个应用的基础，无论如何我希望大家都能喜欢这个视频

131
00:07:40,080 --> 00:07:45,080
如果喜欢………..

