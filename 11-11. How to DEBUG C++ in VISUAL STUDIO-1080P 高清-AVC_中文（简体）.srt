1
00:00:02,067 --> 00:00:03,097
我非常喜欢这些枕头。

2
00:00:04,032 --> 00:00:09,032
嘿，伙计们!我的名字是Cherno，欢迎回到我的c++系列。

3
00:00:09,073 --> 00:00:11,055
今天我们又回到了沙发上。

4
00:00:11,080 --> 00:00:15,000
你们这些家伙似乎觉得没有太多的时间去任何地方看这个视频。

5
00:00:15,041 --> 00:00:18,075
不管怎样，内容将弥补这一点

6
00:00:18,087 --> 00:00:23,017
因为今天我们将要学习如何使用Visual Studio调试我们的代码。 

7
00:00:23,028 --> 00:00:26,077
 不幸的是，在计划这个系列的时候，我面临着一个艰难的决定。

8
00:00:26,087 --> 00:00:31,087
我试着决定哪个视频在哪里，以什么顺序等等.

9
00:00:32,037 --> 00:00:35,067
很多视频都是相互依赖的。

10
00:00:35,072 --> 00:00:40,072
 如果你看到我在某些视频中提到了我在之前的视频中没有提到的东西，

11
00:00:40,082 --> 00:00:43,055
这并不意味着我忽略了

12
00:00:43,056 --> 00:00:47,033
它只是意味着它可能会晚些时候。

13
00:00:47,039 --> 00:00:52,039
尽管如此，调试(Debug)仍然是编程中非常重要的一部分。

14
00:00:52,070 --> 00:00:54,031
而且它不仅仅是编程，还有学习。 

15
00:00:54,042 --> 00:00:56,035
因为如果你知道如何调试你的代码，

16
00:00:56,036 --> 00:00:58,088
你会明白这个程序是如何工作的

17
00:00:58,095 --> 00:01:01,095
以及计算机如何运行你的代码。

18
00:01:02,004 --> 00:01:06,025
所以我认为我已经在本系列的早期就介绍了调试，

19
00:01:06,040 --> 00:01:08,018
因为实际上我将使用很多我们今天介绍的很多内容

20
00:01:08,048 --> 00:01:13,048
来解释其余语言以及计算机程序一般是如何工作的。

21
00:01:13,068 --> 00:01:16,000
在这个视频中，像我所有的c++视频一样，

22
00:01:16,009 --> 00:01:17,072
我将使用Visual Studio。

23
00:01:17,086 --> 00:01:21,082
然而，这些概念几乎适用于任何IDE。

24
00:01:21,088 --> 00:01:25,047
大多数IDE将完全支持我今天在这里展示的内容。

25
00:01:25,063 --> 00:01:27,045
只是可能在不同的地方，

26
00:01:27,051 --> 00:01:31,003
但基本上我们会讲到两个重要的特征…

27
00:01:31,003 --> 00:01:32,095
还是三个?是三吗?我甚至不知道有多少…

28
00:01:33,014 --> 00:01:36,050
我们可以把它分成两部分。

29
00:01:36,066 --> 00:01:37,050
Breakpoints断点

30
00:01:37,057 --> 00:01:41,010
这将是非常有趣的，因为断点是调试的重要部分。

31
00:01:41,010 --> 00:01:42,082
和看内存(memory)。

32
00:01:42,091 --> 00:01:44,085
断点和读取内存

33
00:01:44,099 --> 00:01:47,015
这是调试的两个主要部分。

34
00:01:47,015 --> 00:01:49,056
当然你们会一起使用它们。

35
00:01:49,056 --> 00:01:52,070
换句话说，你需要设置断点来读取内存。

36
00:01:52,070 --> 00:01:54,053
那么调试的意义是什么呢?

37
00:01:54,053 --> 00:01:56,080
我说的调试代码是什么意思?

38
00:01:56,080 --> 00:02:00,043
debug这个词的意思是清除bug，对吧?

39
00:02:00,043 --> 00:02:02,005
从我们的代码中移除bug

40
00:02:02,018 --> 00:02:04,003
为了从我们的代码中移除一个bug，

41
00:02:04,003 --> 00:02:06,010
我们必须诊断我们的程序出了什么问题，

42
00:02:06,013 --> 00:02:08,045
这部分其实很棘手，

43
00:02:08,054 --> 00:02:10,077
即使你对这门语言很有经验。

44
00:02:10,082 --> 00:02:14,025
不管怎么说，你必须记住电脑总是正确的

45
00:02:14,035 --> 00:02:16,070
我说的“总是”是指99%的情况下。

46
00:02:16,075 --> 00:02:21,075
不太可能你做对了但电脑不像预期的那样工作了。

47
00:02:21,086 --> 00:02:24,062
通常是你犯了错。

48
00:02:24,070 --> 00:02:28,015
并逐渐意识到这对程序员来说是非常重要的。

49
00:02:28,026 --> 00:02:31,032
你很快就会发现，电脑几乎总是对的。

50
00:02:31,044 --> 00:02:33,056
所以这都是关于找出你的错误。

51
00:02:33,065 --> 00:02:34,077
我做错了什么？

52
00:02:34,089 --> 00:02:37,000
我做了什么该受这样的惩罚?

53
00:02:37,020 --> 00:02:39,018
所以让我们接下来学习断点和读取内存

54
00:02:39,026 --> 00:02:41,073
这里我有一个非常简单的Visual Studio项目。

55
00:02:41,078 --> 00:02:44,035
这里是主文件，调用log。

56
00:02:44,036 --> 00:02:46,082
这是“Log.cpp”和“Log.h”

57
00:02:46,088 --> 00:02:49,062
就是我们之前讲c++头文件的时候写的。

58
00:02:49,072 --> 00:02:52,052
我们首先要做的是设置一个断点，

59
00:02:52,061 --> 00:02:54,060
然后我们将逐步执行一个程序。

60
00:02:54,071 --> 00:02:56,045
所以什么是断点？

61
00:02:56,046 --> 00:03:01,046
断点是程序中调试器会中断的一个点，

62
00:03:01,074 --> 00:03:04,056
break在这里的意思是暂停。

63
00:03:04,064 --> 00:03:09,064
我们可以在程序的任何一行代码上设置断点。

64
00:03:09,092 --> 00:03:14,085
当执行到达这一行时，它会暂停。

65
00:03:14,090 --> 00:03:19,012
它将悬停该执行线程，或者在我们的例子中，悬停整个程序。

66
00:03:19,019 --> 00:03:22,020
让我们来看看这个项目的状态。

67
00:03:22,024 --> 00:03:24,065
状态，实际上指的是内存。

68
00:03:24,071 --> 00:03:29,071
我们可以暂停程序，看看它的内存中发生了什么。

69
00:03:30,024 --> 00:03:33,077
记住，一个正在运行的程序的内存几乎就是它的全部。

70
00:03:33,085 --> 00:03:36,040
它是每个变量被设置的值。

71
00:03:36,044 --> 00:03:38,043
它是下一个要调用的函数。

72
00:03:38,061 --> 00:03:43,061
内存就是一切。

73
00:03:43,093 --> 00:03:50,075
所以在诊断程序的问题时，能够查看内存是非常有用的。

74
00:03:51,016 --> 00:03:54,052
因为通过查看内存，你可以看到每个变量被设置成什么样子

75
00:03:54,059 --> 00:03:57,090
就像“嘿，这个变量不应该设为这个值”

76
00:03:57,097 --> 00:03:59,010
“显然是错误的。”

77
00:03:59,027 --> 00:04:02,062
你还可以逐行执行程序，

78
00:04:02,069 --> 00:04:06,056
我可以在第5行放一个断点，然后点击一个按钮

79
00:04:06,067 --> 00:04:11,015
程序只会将一行代码推进到第6行

80
00:04:11,027 --> 00:04:14,075
你也可以直接执行函数，看看它们会把你带到哪里

81
00:04:14,078 --> 00:04:19,008
使用断点可以做的事情太多了

82
00:04:19,012 --> 00:04:21,067
如果你编程却不会用断点，那我都不知道你在干什么。

83
00:04:21,080 --> 00:04:23,010
所以，回到Visual Studio

84
00:04:23,013 --> 00:04:25,048
为了在Visual Studio中设置断点，

85
00:04:25,057 --> 00:04:29,052
你可以按F9，它会在当前这行代码上设置一个断点，

86
00:04:29,063 --> 00:04:32,060
或者你可以点击这个侧边栏，在侧边栏的任何地方。

87
00:04:32,078 --> 00:04:34,088
只需单击一次，就可以设置断点。

88
00:04:34,099 --> 00:04:38,020
显然，如果在第3行设置断点没什么用，

89
00:04:38,026 --> 00:04:41,052
因为第3行没有任何东西会被执行。

90
00:04:41,062 --> 00:04:47,025
所以一定要设置断点在实际执行的代码上。

91
00:04:47,032 --> 00:04:51,005
所以第6行，肯定会被执行，因为这是主函数的第一行代码

92
00:04:51,012 --> 00:04:53,090
然后你所要做的就是通过调试器运行你的代码。

93
00:04:53,095 --> 00:04:56,085
一个提示是确保你处于debug模式，

94
00:04:56,087 --> 00:05:01,005
因为如果你在release模式，编译器实际上会改变代码，

95
00:05:01,013 --> 00:05:05,073
你的断点可能永远不会被执行，因为你的程序被重新安排了

96
00:05:06,010 --> 00:05:09,073
我们以后将更深入地讨论release模式实际上是做什么的。

97
00:05:09,073 --> 00:05:12,080
但要点是，如果正在调试，只要确保处于调试(Debug)模式即可。

98
00:05:12,085 --> 00:05:14,099
如果我们点击本地windows调试器，

99
00:05:15,012 --> 00:05:17,030
它能确保你在运行的时候附加了调试器，

100
00:05:17,042 --> 00:05:27,092
我们的程序将执行，而且你会发现Visual Studio变成了这种不同的交替布局

101
00:05:28,009 --> 00:05:30,092
亮点上有一个大大的黄色箭头

102
00:05:31,009 --> 00:05:35,027
指示当前指令指针所在的位置。

103
00:05:35,033 --> 00:05:38,073
在这里要看的主要区域基本上是这个“继续”(Continue)按钮，

104
00:05:38,080 --> 00:05:41,080
它将像往常一样继续执行程序。

105
00:05:41,085 --> 00:05:43,088
然后这里有一堆按钮，

106
00:05:44,010 --> 00:05:46,070
让我们"step into""step over"或"step out"。

107
00:05:46,093 --> 00:05:50,095
这三个按钮将精确地控制程序接下来会发生什么

108
00:05:51,006 --> 00:05:54,073
所以“step into”会进入当前函数

109
00:05:54,083 --> 00:05:57,020
如果有函数，它就在这行代码中。

110
00:05:57,030 --> 00:06:00,042
所以在这种情况下，如果我进入log。

111
00:06:00,052 --> 00:06:02,075
我们会进入log函数

112
00:06:02,076 --> 00:06:04,060
这样我们就能看到它的作用。

113
00:06:04,078 --> 00:06:09,017
“Step over”将转到当前函数的下一行代码，

114
00:06:09,031 --> 00:06:14,088
“step out”实际上是要跳出当前函数，让我们回到这个函数

115
00:06:15,025 --> 00:06:17,057
在这个例子下，因为这是主函数，

116
00:06:17,070 --> 00:06:19,023
将是C标准库。

117
00:06:19,028 --> 00:06:24,028
你还可以使用F11来step into，F10来step over，Shift+F11来step out。

118
00:06:24,060 --> 00:06:27,012
让我们step into这个log函数，看看会发生什么。

119
00:06:27,017 --> 00:06:29,065
按F11。OK，看看这个。

120
00:06:29,081 --> 00:06:33,005
所以我们进入这个函数，我们在堆栈的最开始。

121
00:06:33,017 --> 00:06:37,085
我们还没有开始执行任何代码，我们只是设置函数堆栈框架

122
00:06:38,000 --> 00:06:41,033
我们可以将鼠标悬停在这个message变量上并检查它

123
00:06:41,039 --> 00:06:43,065
它告诉我们它被设置为“Hello World!”

124
00:06:43,077 --> 00:06:48,040
这就是调试的第二部分，我们在读取内存

125
00:06:48,055 --> 00:06:51,070
如果我按下F10，它会把我们带到这一行代码。

126
00:06:51,086 --> 00:06:58,010
黄色箭头在这行代码上，意味着它还没有执行这行代码。

127
00:06:58,033 --> 00:07:00,030
它就在那里。这是真的。

128
00:07:00,055 --> 00:07:07,070
只要我们按下F10或Shift+F11来退出函数或者F5来继续项目…

129
00:07:07,078 --> 00:07:11,095
只要我们按下其中一个，就会执行那一行代码，甚至更多。

130
00:07:12,001 --> 00:07:14,075
但是黄色箭头表示它在这一行代码上。

131
00:07:14,084 --> 00:07:17,023
它还没有实际执行那行代码

132
00:07:17,028 --> 00:07:22,025
如果我现在打开程序，你可以看到“Hello World!”信息还没有打印出来

133
00:07:22,036 --> 00:07:27,005
但是看看这个，按F10，然后再检查看看。

134
00:07:27,014 --> 00:07:31,002
我们打印了“Hello World!”因为我们把它叫做“std::cout”函数，

135
00:07:31,014 --> 00:07:33,040
它将文本打印到控制台

136
00:07:33,055 --> 00:07:35,020
我们已经执行了那个函数。

137
00:07:35,026 --> 00:07:38,090
通过设置断点和逐步执行我们的程序，

138
00:07:38,095 --> 00:07:42,052
我们可以逐行运行整个程序

139
00:07:42,055 --> 00:07:44,057
这真的很酷很有用

140
00:07:44,084 --> 00:07:46,088
当你试图找出自己做错了什么的时候。

141
00:07:47,000 --> 00:07:49,035
回到这里，如果我们继续按F10

142
00:07:49,055 --> 00:07:52,012
你会看到我们最终会回到我们的主函数。

143
00:07:52,023 --> 00:07:54,092
点击F10会把我们带到主函数的下一行代码，

144
00:07:54,094 --> 00:07:56,055
然后继续下去。

145
00:07:56,070 --> 00:08:04,018
如果我按下F5来继续运行程序，我可以按下回车键来关闭我的程序，就像它在正常运行一样

146
00:08:04,042 --> 00:08:05,048
好吧，这是个很酷的东西。

147
00:08:05,057 --> 00:08:09,085
虽然这看起来很简单，但这就是它的全部。

148
00:08:10,008 --> 00:08:12,025
我的意思是我已经给你们展示了几乎所有的东西。

149
00:08:12,037 --> 00:08:14,023
我会给你们看更多的例子，这样你们就能真正理解，

150
00:08:14,030 --> 00:08:16,048
但这就是它的要点。

151
00:08:16,049 --> 00:08:19,035
我们继续创建一些变量来让事情变得有趣。

152
00:08:19,045 --> 00:08:22,092
我要创建一个整数，叫a，设它等于8。

153
00:08:23,005 --> 00:08:26,008
我要用“a++”，它会使a增加1。

154
00:08:26,028 --> 00:08:27,092
换句话说，它会把a设为9。

155
00:08:27,099 --> 00:08:34,038
我要在这里创建一个C字符串，在控制台输入 const char* string = "Hello";

156
00:08:34,045 --> 00:08:40,047
我要写一个非常基本的for循环来迭代这个字符串，并将每个字符打印在单独的行上。

157
00:08:40,078 --> 00:08:43,078
然后我会在我的log留下“Hello World!”

158
00:08:43,092 --> 00:08:47,072
如果我不设断点运行程序，看看会发生什么

159
00:08:47,086 --> 00:08:52,030
你会看到我们有“Hello”和“Hello World”

160
00:08:52,088 --> 00:08:55,015
好吧。现在我一行一行地来。

161
00:08:55,026 --> 00:08:58,085
所以我想在最上面的int a上设置一个断点，然后按F5

162
00:08:58,098 --> 00:09:01,020
好，我们来看看a是什么。

163
00:09:01,027 --> 00:09:04,070
为什么它是负8.58亿？

164
00:09:04,081 --> 00:09:09,062
好。记住，黄色箭头并不意味着我们运行了这段代码。

165
00:09:09,077 --> 00:09:11,067
我们正要运行它，

166
00:09:11,067 --> 00:09:13,085
但实际上我们还没有执行第6行。

167
00:09:13,085 --> 00:09:16,022
就是实际创建并设置“变量”的那一行。

168
00:09:16,053 --> 00:09:22,025
所以调试器现在给我们显示的是内存

169
00:09:22,025 --> 00:09:24,097
因为我们还没有把这个变量设为任何值，

170
00:09:25,012 --> 00:09:26,088
它只是一个未初始化的内存，

171
00:09:26,099 --> 00:09:30,065
这意味着这个值只是显示给我们，并不是内存实际的值。

172
00:09:30,081 --> 00:09:35,081
这将是一个极好的时间来引出这三个重要的窗口：

173
00:09:35,098 --> 00:09:37,070
Autos, Locals and Watch。

174
00:09:37,070 --> 00:09:43,085
Autos和Locals基本上只是向你展示局部变量或者对你来说重要的变量。

175
00:09:43,092 --> 00:09:47,038
Watch，从另一方面，让我们实际监控变量。

176
00:09:47,047 --> 00:09:52,022
所以我能做的就是输入变量的名字“a”，然后按下回车键。

177
00:09:52,033 --> 00:09:54,072
你可以看到它显示了a的值。

178
00:09:54,079 --> 00:09:58,078
如果我还想查看“string”是什么，我也可以把它放进去，

179
00:09:58,081 --> 00:10:00,040
它会告诉我“string”是什么。

180
00:10:00,061 --> 00:10:02,083
当然，我们还没有初始化这个内存，

181
00:10:02,093 --> 00:10:05,057
所以它目前完全没用。这只是垃圾。

182
00:10:05,064 --> 00:10:10,022
但是当我们逐步完成我们的项目时，这些值将更新以确定内存中实际存在的内容。

183
00:10:10,027 --> 00:10:15,005
说到内存，实际上有一个视图我们可以用来查看整个程序的内存。

184
00:10:15,013 --> 00:10:16,078
当然，这叫做内存视图。

185
00:10:16,086 --> 00:10:21,000
所以如果我们调试→Windows→内存→内存1

186
00:10:21,009 --> 00:10:23,097
迎接我们的将是这个奇怪的面板

187
00:10:24,009 --> 00:10:26,067
这将显示我们程序的所有内存。

188
00:10:26,080 --> 00:10:29,022
在最左边，我们看到了内存地址。

189
00:10:29,033 --> 00:10:34,033
在中间，我们看到了数据的实际值，它是以十六进制表示的。

190
00:10:34,049 --> 00:10:38,025
在右边，我们看到的是对这些数字的ASCIl解释。

191
00:10:38,038 --> 00:10:44,083
如果你想定位变量a实际存储在程序内存的哪个位置，你需要知道它的内存地址。

192
00:10:44,084 --> 00:10:48,050
要做到这一点，我们只需输入“&”和“a”。

193
00:10:48,054 --> 00:10:52,062
所以变量名前面的&会取到此变量的内存地址。

194
00:10:52,083 --> 00:10:57,083
如果我们回车，就会被带到变量a的内存地址

195
00:10:57,083 --> 00:10:59,065
在这种情况下，就是一大堆C。

196
00:10:59,086 --> 00:11:04,015
所以那个数字，cc，实际上是一个十六进制数。

197
00:11:04,030 --> 00:11:07,067
如果你想知道它的十进制表示，你可以调出计算器。

198
00:11:07,081 --> 00:11:11,083
如果我们切换到程序员视图，我们可以输入十六进制值。

199
00:11:11,084 --> 00:11:17,097
如果我点击十六进制，输入cc，你可以看到它就是：204

200
00:11:18,002 --> 00:11:20,090
所以204，cc，为什么会这样呢?

201
00:11:20,094 --> 00:11:23,030
内存不应该是随机的吗?

202
00:11:23,037 --> 00:11:26,047
一大堆“cc”似乎是特定的

203
00:11:26,056 --> 00:11:28,045
这就是调试模式很酷的地方

204
00:11:28,053 --> 00:11:30,085
以及为什么调试模式会减慢我们的程序

205
00:11:30,087 --> 00:11:34,053
因为编译器会让程序做某些事情，

206
00:11:34,060 --> 00:11:39,025
一些会让我们便于调试的额外的事情。

207
00:11:39,032 --> 00:11:46,020
举个例子，这个内存是一大堆“cc”的事实，意味着它是一个未初始化的堆栈内存。

208
00:11:46,025 --> 00:11:50,078
实际上，编译器知道我们在尝试创建一个变量，

209
00:11:50,078 --> 00:11:52,055
但是我们还没有初始化。

210
00:11:52,065 --> 00:11:57,010
我们要做的就是用cc来填充内存

211
00:11:57,023 --> 00:11:59,088
所以如果我们在调试代码时出错了，

212
00:12:00,003 --> 00:12:01,067
我们可以看看内存。

213
00:12:01,069 --> 00:12:03,040
我们可以看到它被设置为“cc”

214
00:12:03,047 --> 00:12:06,050
我们可以这样说：“当然！我从来没有初始化过那个变量。”

215
00:12:06,060 --> 00:12:08,017
“这就是为什么这一切都错了。”

216
00:12:08,021 --> 00:12:12,092
现在通过做一些额外的事情，比如在初始化内存之前将其设置为“cc”

217
00:12:13,003 --> 00:12:16,065
很明显，我们的程序正在做一些额外的事情所以使速度变慢了

218
00:12:16,076 --> 00:12:18,072
我们不想在release模式中这样做

219
00:12:18,080 --> 00:12:22,005
当我们真正relese我们的程序或发行游戏时，我们不想这样做

220
00:12:22,009 --> 00:12:24,042
但是在调试时，它非常有用。

221
00:12:24,047 --> 00:12:28,053
如果我像这样，按下F10，很多事情将会发生。

222
00:12:28,061 --> 00:12:31,045
你可以在这个Watch窗口中做的另一件事是

223
00:12:31,045 --> 00:12:33,090
右击并选择十六进制显示。

224
00:12:33,098 --> 00:12:38,015
现在你可以看到a的值实际上是一串" C "。

225
00:12:38,027 --> 00:12:42,038
当然，这意味着“a”当前是一个未初始化的堆栈内存。

226
00:12:42,044 --> 00:12:45,092
让我们回到非十六进制显示，按下F10。

227
00:12:45,092 --> 00:12:48,000
一些很酷的事情将会发生。

228
00:12:48,014 --> 00:12:52,010
也就是说，在这个Watch窗口中的值已经变成了8。

229
00:12:52,017 --> 00:12:56,000
它也是红色的，表示它从最后一个断点开始改变。

230
00:12:56,002 --> 00:12:57,047
我们的指令指针向下移动了，

231
00:12:57,051 --> 00:12:59,062
这表明它即将被执行。

232
00:12:59,088 --> 00:13:01,050
这行代码还没有做到这一点

233
00:13:01,059 --> 00:13:02,090
不，不，不！还没有。

234
00:13:02,096 --> 00:13:04,025
但很快就会。

235
00:13:04,044 --> 00:13:06,012
然后如果我们看一下内存视图，

236
00:13:06,015 --> 00:13:10,083
您还可以看到这四个字节(byte)的内存被设置为8。

237
00:13:10,093 --> 00:13:15,030
顺便说一下，我应该提一下这里的每两个数字等于1字节(byte)。

238
00:13:15,042 --> 00:13:18,008
这也是为什么我们用十六进制来表示，

239
00:13:18,038 --> 00:13:23,038
因为如果我们这样做，每两个十六进制数字总是对齐为一个字节内存。

240
00:13:23,062 --> 00:13:28,062
所以我们可以通过观察这个来判断这8个十六进制数字是内存字节，

241
00:13:28,083 --> 00:13:31,053
你可以看到它被设为8。

242
00:13:31,063 --> 00:13:33,057
这就是我们要做的。这就是我们现在所做的。

243
00:13:33,068 --> 00:13:36,038
我们已经暂停了程序，现在看一下它的状态。

244
00:13:36,039 --> 00:13:37,065
我们正在读取它的内存。

245
00:13:37,075 --> 00:13:39,017
如果我再按一次F10，

246
00:13:39,022 --> 00:13:40,003
我们前进了一步。

247
00:13:40,014 --> 00:13:41,060
现在设置为9。

248
00:13:41,070 --> 00:13:43,060
这里也设为9。

249
00:13:43,065 --> 00:13:44,088
酷

250
00:13:44,088 --> 00:13:47,028
你可以看到“string”仍然是未初始化的堆栈内存，

251
00:13:47,028 --> 00:13:48,003
但是看看这个

252
00:13:48,005 --> 00:13:50,078
我要在这行中初始化它，如果我按下F10，

253
00:13:50,099 --> 00:13:54,020
它被初始化，因为这是一个实际的指针，

254
00:13:54,024 --> 00:13:57,035
它还告诉我们那个字符串的内存地址。

255
00:13:57,045 --> 00:14:04,067
如果我从Watch窗口复制这个内存地址，粘贴到我的内存视图中，然后回车。

256
00:14:04,073 --> 00:14:06,042
看，我被带到这些字节，

257
00:14:06,042 --> 00:14:10,097
在ASCIl的解释中，你可以看到它是“Hello”。

258
00:14:11,014 --> 00:14:14,070
有趣的是，如果你继续读下去，

259
00:14:14,076 --> 00:14:19,080
你可以看到，内存中靠近"Hello"的下面有

260
00:14:19,080 --> 00:14:23,047
"Stack around the variable '.' was corrupted（变量周围的堆栈已损坏）"

261
00:14:23,052 --> 00:14:27,040
"The variable '..' is being used without being initialized（变量在未初始化的情况下被使用）"

262
00:14:27,055 --> 00:14:31,066
显然，我们的程序包含了字符串，比如内存中的"Stack around the variable '.' was corrupted"

263
00:14:31,090 --> 00:14:34,047
这在发布(release)模式中是不存在的，

264
00:14:34,064 --> 00:14:39,000
但这是另一个很好的例子，说明在调试模式下实际会发生什么，以帮助您调试程序。

265
00:14:39,004 --> 00:14:42,078
好吧，当然，这里的事情变得非常有趣，因为我们遇到了这个“for”循环。

266
00:14:42,085 --> 00:14:45,042
如果我继续前进会怎么样？

267
00:14:45,060 --> 00:14:49,088
现在我们还没有在本系列中介绍“for”循环或任何类型的控制流语句。

268
00:14:49,095 --> 00:14:52,067
接下来的几段视频可能会解决这个问题。

269
00:14:52,075 --> 00:14:54,050
我真的想先介绍一下调试器

270
00:14:54,066 --> 00:14:58,078
这样我们就可以在将来逐步了解这些控制流语句，看看它们是如何工作的。

271
00:14:58,093 --> 00:15:01,065
而你们就已经知道如何使用这个调试视图了。

272
00:15:01,080 --> 00:15:04,003
但基本上，它会做很多次。

273
00:15:04,013 --> 00:15:08,028
所以如果我们逐步完成这个程序，你可以看到“i”被设置为0

274
00:15:08,035 --> 00:15:11,003
它将从这个字符串中获取索引[0]，

275
00:15:11,003 --> 00:15:13,085
这将是字符串中的第一个字符，

276
00:15:14,017 --> 00:15:15,095
它是一个大写的H。

277
00:15:16,004 --> 00:15:20,020
如果我们按F10键，我们可以将鼠标悬停在“c”上，看它是否设置为“H”。

278
00:15:20,028 --> 00:15:24,015
我们也可以到这儿看看，然后输入“c”

279
00:15:24,040 --> 00:15:26,030
你可以看到，我们现在正在看“c”是什么。

280
00:15:26,049 --> 00:15:29,083
当我按F10键时，它会打印这个字母到控制台。

281
00:15:30,002 --> 00:15:34,035
然后当它回到这个大括号，它将运行这个比较。

282
00:15:34,064 --> 00:15:36,095
如果“i”小于5，它将进行比较。

283
00:15:37,015 --> 00:15:41,038
然后，如果是这样，它会增加“i”，然后跳回到这里。

284
00:15:41,054 --> 00:15:44,075
所以如果我按F10，你可以看到我们跳到这里来做比较。

285
00:15:44,089 --> 00:15:48,057
如果我再按F10，我们就完成了“i++”，i现在是1

286
00:15:48,077 --> 00:15:50,095
我们要重新做同样的事情。

287
00:15:51,005 --> 00:15:57,060
这次“i”是1，所以它将抓取第二个字符，即字母“e”，然后继续。

288
00:15:57,074 --> 00:16:01,047
此时，c等于“e”，在我们的Watch中已经改变了。

289
00:16:01,061 --> 00:16:10,035
如果我们来到这里，输入“&c”并按回车，可以看到显示65，根据ASCII码，这是字母e。

290
00:16:10,037 --> 00:16:13,080
好极了！我可以一直坚持下去，就这样做。

291
00:16:13,096 --> 00:16:18,020
现在假设我想退出这个循环函数，跳入log函数

292
00:16:18,038 --> 00:16:19,078
我真的在乎跨过这个

293
00:16:20,001 --> 00:16:21,053
我知道它是如何工作的

294
00:16:21,053 --> 00:16:23,033
我怎么才能从这个for循环中出来？

295
00:16:23,047 --> 00:16:28,005
如果我尝试跳出或点击Shift +F11，它实际上要退出整个函数。

296
00:16:28,024 --> 00:16:32,025
我不想这样做。我只是想继续运行for循环，然后停在这里。

297
00:16:32,025 --> 00:16:33,022
我该怎么做？

298
00:16:33,038 --> 00:16:37,065
很简单，你所要做的就是在下一个要停止的地方设置一个断点。

299
00:16:37,089 --> 00:16:44,030
如果我点击F5或按此处的继续按钮，它实际上将运行我的程序，直到它到达下一个断点

300
00:16:44,059 --> 00:16:46,012
在本例中，这是一个log函数

301
00:16:46,030 --> 00:16:51,038
所以到现在为止，这个c变量在内存中被设置为“o”

302
00:16:51,052 --> 00:16:53,057
它实际上仍然active，那个内存仍然在，

303
00:16:53,057 --> 00:16:55,092
我们将在未来讨论这个问题。

304
00:16:56,004 --> 00:16:59,028
但是内存被设置为“Hello”一词的最后一个字符。

305
00:16:59,037 --> 00:17:02,092
如果我们带回我们的程序，你可以看到它打印了整个“Hello”。

306
00:17:02,093 --> 00:17:06,050
然后我们就要执行这个“Hello World“log函数。

307
00:17:06,071 --> 00:17:09,097
按F10，我们将跳转到下一行代码。

308
00:17:10,008 --> 00:17:11,060
这里要打印“Hello World”。

309
00:17:11,067 --> 00:17:16,067
现在我们已经暂停了这个程序的执行，因为这里有一个断点，我刚刚按了F10。

310
00:17:16,076 --> 00:17:19,040
所以如果我按回车键，什么都不会发生。

311
00:17:19,047 --> 00:17:24,047
我需要按F5键，然后我们的程序将关闭，因为它仍将检测到按回车键。

312
00:17:24,074 --> 00:17:29,074
就这样，基本调试的一个非常简单的概述。

313
00:17:29,079 --> 00:17:37,088
通过这样我们能做到更多，但我刚才在这段视频中展示的是实际如何调试代码的基础。

314
00:17:38,006 --> 00:17:41,000
记住，一个程序实际上是由内存组成的

315
00:17:41,050 --> 00:17:48,034
甚至指令指针，我们正在执行的实际代码…

316
00:17:48,034 --> 00:17:50,015
所有这些都存储在内存中。

317
00:17:50,043 --> 00:17:54,093
因此，能够查看我们的内存是我们真正拥有的，真正需要的，

318
00:17:55,006 --> 00:18:00,093
并且通过设置断点，它允许我们在给定的时间，在给定的代码行暂停一个程序。

319
00:18:01,010 --> 00:18:06,010
实际上，检查一下它，看看我们所有的变量都设置了什么，

320
00:18:06,024 --> 00:18:09,022
当然，在运行代码时，它会非常有用

321
00:18:09,028 --> 00:19:01,003
（结束语）

