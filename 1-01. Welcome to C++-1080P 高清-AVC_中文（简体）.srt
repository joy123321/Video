1
00:00:00,000 --> 00:00:02,033
Hey大家吼啊，我叫Cherno   

2
00:00:02,033 --> 00:00:04,010
欢迎来到一个全新的系列！

3
00:00:04,012 --> 00:00:07,045
本系列将带你了解C++你所需要知道的一切。

4
00:00:07,069 --> 00:00:10,062
我们将主要学习游戏开发中的C++

5
00:00:10,075 --> 00:00:13,088
然而，并不是说只运用于游戏开发或者游戏编程

6
00:00:13,098 --> 00:00:16,067
我们只是用游戏来举例子

7
00:00:16,092 --> 00:00:18,060
本系列其实适用于任何人

8
00:00:18,076 --> 00:00:20,045
无论你是初级还是高级

9
00:00:20,065 --> 00:00:22,000
我们会设计C++的基础

10
00:00:22,010 --> 00:00:24,023
但会非常简洁

11
00:00:24,035 --> 00:00:28,008
所以，如果你是初学者，你仍然可以跟着学下去

12
00:00:28,020 --> 00:00:34,000
但你得能够去搜索、研究、自己去找一些基础的东西

13
00:00:34,013 --> 00:00:37,010
基本上就是做个正常人，能自己去谷歌你不懂的东西

14
00:00:37,026 --> 00:00:40,055
我不打算在基础上细讲太久，或者极尽详细的介绍

15
00:00:40,078 --> 00:00:42,088
所以你得确保自己搜索一些东西，你可以的！

16
00:00:43,025 --> 00:00:46,088
所以问题来了，我为啥要学C++呢？

17
00:00:46,099 --> 00:00:49,033
难道C++不是有点过时了吗？

18
00:00:49,050 --> 00:00:51,057
现在学C++有什么好处？

19
00:00:51,069 --> 00:00:58,040
其实C++仍然是当你需要写效率很高的代码时最常用的语言

20
00:00:58,051 --> 00:01:02,065
或者你在写一个诡异的架构或者平台，然后你需要让代码本地(native)运行

21
00:01:02,084 --> 00:01:05,055
如果你要对硬件的直接控制，C++就是为你而生

22
00:01:05,060 --> 00:01:08,065
比如说游戏行业就大量运用C++

23
00:01:08,071 --> 00:01:13,043
像Unity、Unreal、frostbite之类的游戏引擎都是用C++写的

24
00:01:13,070 --> 00:01:16,030
那我们为什么要对硬件的直接控制呢？

25
00:01:16,040 --> 00:01:20,025
为什么这些引擎都是用C++写的，而非其他语言呢？ 

26
00:01:20,039 --> 00:01:23,088
最主要的原因就是C++能直接控制硬件

27
00:01:23,099 --> 00:01:26,015
我们来稍微讲一下C++是如何工作的

28
00:01:26,028 --> 00:01:30,075
你用C++写好代码，传入编译器(compiler)

29
00:01:30,087 --> 00:01:34,085
然后编译器会为你的目标平台产出机器码

30
00:01:34,093 --> 00:01:39,043
机器码是你设备的CPU执行的真正指令

31
00:01:39,052 --> 00:01:45,043
所以用C++我们完全可以控制你CPU执行的每一条指令

32
00:01:45,048 --> 00:01:48,047
你问C++可以在什么平台运行？基本上任何平台

33
00:01:48,057 --> 00:01:52,028
你只需要一个能产出那个平台的机器码的编译器即可

34
00:01:52,037 --> 00:01:56,010
比如说一个x64编译器会产出x64机器码

35
00:01:56,024 --> 00:01:58,020
从而在x64 CPU上运行

36
00:01:58,031 --> 00:02:07,043
举个例子，包括Windows,Mac,Linux,其他桌面操作系统（基本上所有的）都是C++开发的

37
00:02:07,059 --> 00:02:12,023
移动操作系统比如iOS，Android，你也都可以用C++来写应用

38
00:02:12,027 --> 00:02:19,073
以及所有主机，XBox，PlayStation和所有任天堂的比如3ds,wii u,switch，一切

39
00:02:20,010 --> 00:02:22,085
当你需要支持很多平台的时候，C++是非常好的选择

40
00:02:22,091 --> 00:02:29,005
因为只要有一个编译器，你就可以把代码编译成能在该平台上运行的native code

41
00:02:29,019 --> 00:02:31,088
当然市面上还有其他native语言

42
00:02:32,002 --> 00:02:37,062
只不过C++从80年代初就出现了，而且很流行，所有人都知道

43
00:02:38,045 --> 00:02:40,056
所有人都在用它

44
00:02:40,068 --> 00:02:44,062
其他语言比如C#和Java不一样，因为它们在虚拟机中运行

45
00:02:44,078 --> 00:02:48,012
这表示你的代码会首先被编译成一种中间语言

46
00:02:48,021 --> 00:02:56,025
然后当你在目标平台运行你的应用时，虚拟机会在runtime将代码转化成机器码

47
00:02:56,030 --> 00:02:57,090
如果你愿意，可以想象一下

48
00:02:57,090 --> 00:03:02,073
比方说你用英语写了本书，然后你想让某个德国读者读懂它

49
00:03:02,098 --> 00:03:12,023
所以你决定在德国书店销售英语版本，但是你买书的时候同时会获得一个翻译

50
00:03:12,038 --> 00:03:15,035
一个真的人跟你回家

51
00:03:15,045 --> 00:03:17,056
我知道这个暗喻稍微有点诡异，请再容忍我一会

52
00:03:17,072 --> 00:03:21,095
当这个人回家了，这个德国读者想看这本书时

53
00:03:22,005 --> 00:03:27,050
这个翻译呢，用英文看那本书然后一边用德语讲出来

54
00:03:27,064 --> 00:03:30,010
所以他就像在即时翻译整本书

55
00:03:30,017 --> 00:03:32,073
这基本上就有点像虚拟机干的事

56
00:03:32,086 --> 00:03:39,068
把书直接翻译成德语然后直接卖德语版本显然更有效率

57
00:03:39,081 --> 00:03:43,023
这样的话就是本土语言——德语了

58
00:03:43,035 --> 00:03:49,056
当然这不是特别完美的比方了，但这基本就是运行C++和其他语言比如Java和C#的区别了

59
00:03:49,072 --> 00:03:58,038
C++是本土语言，C++编译器为那个平台和架构编译出机器码，就完事了，就是native的

60
00:03:58,055 --> 00:04:03,012
编译出的机器码只会运行于这个平台，但这就是这个平台的机器码了

61
00:04:03,023 --> 00:04:12,050
绝对没有任何“翻译”的需要了，它就能直接运行了

62
00:04:12,062 --> 00:04:17,012
当然，你的代码现在是native了，并不是说它就一定很快

63
00:04:17,021 --> 00:04:25,057
如果你用C++写垃圾代码，一样很慢，甚至更有可能会比虚拟机语言(C#,Java)更慢

64
00:04:25,069 --> 00:04:29,017
因为它们会在运行时优化很多东西而C++不会

65
00:04:29,034 --> 00:04:34,034
所以你如果写垃圾代码，C++绝对比C#和Java慢

66
00:04:34,062 --> 00:04:38,042
正因为此，我喜欢用那些语言比如C#只是写一些工具

67
00:04:38,054 --> 00:04:45,040
或者那些不需要我榨干所有性能的时候，C#是一个超好的语言

68
00:04:45,061 --> 00:04:50,015
但本系列是为那些我们需要那种性能的时候，我们需要用C++

69
00:04:50,031 --> 00:04:55,057
所以我们会学到如何正确的写C++代码，如何写好的代码，如何写速度快的代码

70
00:04:55,069 --> 00:04:58,077
所以你会问那我们会涵盖哪些内容呢？

71
00:04:58,098 --> 00:05:06,062
当然，一开始我们会从基础讲起，基础的东西我会很简洁，因为我不想花太多时间在上面

72
00:05:06,077 --> 00:05:15,055
如果你从来没编程过，我仍然鼓励你观看本系列，但正如我之前所说，你得学会搜索

73
00:05:15,065 --> 00:05:17,045
应该会比较容易跟上

74
00:05:17,052 --> 00:05:22,052
学习任何新东西其实就是多盘它，多试验

75
00:05:22,076 --> 00:05:28,062
所以我相信你绝对ok的，只要你有激情，以及想要去学

76
00:05:28,075 --> 00:05:31,077
我们还会学到如何有利的使用库

77
00:05:31,094 --> 00:05:34,005
什么当避免如果你要性能的话

78
00:05:34,021 --> 00:05:38,065
我们会讲到C++到底是如何工作的，我们会讲内存(memory)和指针(pointer)

79
00:05:38,076 --> 00:05:43,017
讲真，不知道为啥，很多教程教这些东西都教得稀烂

80
00:05:43,028 --> 00:05:47,023
所以我们这次会正确的教指针和内存等东西

81
00:05:47,040 --> 00:05:52,083
内存池(memory arena), custom allocator, smart pointer(智能指针), move semantics(移动语义)等等

82
00:05:52,093 --> 00:05:59,048
摸板(template)以及如何正确的使用它们，如果你懂得用好templates，它们非常强大，让你的工作轻松不少

83
00:05:59,062 --> 00:06:03,017
我们会讲宏(macro)以及怎么给多平台编程

84
00:06:03,025 --> 00:06:08,060
我们会创建自己的数据结构，并学习如何让它们运行比std库里还快

85
00:06:08,076 --> 00:06:12,038
我们甚至会涉及底层优化，比如编译器内联(compiler intrinsics)和汇编(assemblies)

86
00:06:12,053 --> 00:06:14,052
比如写我们自己的map和SSE

87
00:06:14,076 --> 00:06:23,065
这就是所有的了，过程中我们可能还会涵盖其他的，如果你们有希望我讲的（能讲10分钟以上的）

88
00:06:23,085 --> 00:06:26,055
我会做个视频讲它们

89
00:06:26,061 --> 00:06:31,061
如果你好奇我是谁，我是一个软件工程师，在EA墨尔本的游戏引擎团队

90
00:06:31,073 --> 00:06:34,077
我们制作基本上市面上最好的3d移动端游戏引擎

91
00:06:34,085 --> 00:06:39,085
我们最近发布的游戏有极品飞车No Limits和No Limits VR，你可以在instagram或者tweeter关注我（后面就不翻译了）

