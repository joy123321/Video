1
00:00:00,000 --> 00:00:00,081
大家好

2
00:00:00,081 --> 00:00:03,066
我是cherno，欢迎来到另一个视频

3
00:00:03,066 --> 00:00:05,073
当我们讨论c++中的函数

4
00:00:05,073 --> 00:00:09,096
“什么？！周中也有视频？我在做梦吗？还是Cherno疯了？”

5
00:00:09,096 --> 00:00:10,080
也许吧

6
00:00:10,080 --> 00:00:14,055
但这不是重点，我只是想对所有喜欢这个系列的人说声谢谢

7
00:00:14,055 --> 00:00:18,006
我真的很高兴你们喜欢这个，因为这真的很有乐趣

8
00:00:18,006 --> 00:00:20,043
如果你想让我知道你对我的视频有多喜欢

9
00:00:20,043 --> 00:00:21,072
你可以在Instagram上关注我

10
00:00:21,072 --> 00:00:22,092
链接在视频描述中

11
00:00:22,092 --> 00:00:24,051
最近我很喜欢摄影

12
00:00:24,051 --> 00:00:25,056
如果你们能关注我，对我来说意义很大

13
00:00:25,056 --> 00:00:32,001
比如说暂停这段视频，先去关注我。不管怎样，回到functions

14
00:00:32,001 --> 00:00:33,063
那么函数到底是什么呢

15
00:00:33,063 --> 00:00:38,085
这些函数基本上是我们编写的代码块，它们被设计用来执行某个特定的任务

16
00:00:38,085 --> 00:00:40,002
当我们讲到class（类）的时候

17
00:00:40,002 --> 00:00:42,018
那些代码块被称为methods（方法）

18
00:00:42,018 --> 00:00:43,038
但是当我说function（函数）时

19
00:00:43,038 --> 00:00:46,062
我是在明确地说某种不属于某个class的东西

20
00:00:46,062 --> 00:00:50,025
对于我们来说，分割函数以防止重复代码是很常见的

21
00:00:50,025 --> 00:00:53,043
我们不希望多次写同一段代码，因为

22
00:00:53,043 --> 00:00:54,018
如果我们这样做了

23
00:00:54,018 --> 00:00:59,052
显然，除了复制和粘贴大量的代码，并最终获得一团糟以外

24
00:00:59,052 --> 00:01:02,037
也意味着，如果我们决定改变一些代码

25
00:01:02,037 --> 00:01:05,097
我们必须在所有粘贴原始代码的地方改变它

26
00:01:05,097 --> 00:01:08,007
这对维护来说将会是一场灾难

27
00:01:08,007 --> 00:01:12,056
所以我们可以做的就是写一个函数来做我们想做的

28
00:01:12,056 --> 00:01:14,049
然后我们可以在代码中多次调用它，

29
00:01:14,049 --> 00:01:15,024
在我们需要的时候。

30
00:01:15,024 --> 00:01:18,015
你可以这么理解函数，有一个输入和一个输出

31
00:01:18,015 --> 00:01:20,007
尽管这并非绝对必要的

32
00:01:20,007 --> 00:01:22,071
我们可以提供特定的参数

33
00:01:22,071 --> 00:01:24,069
然后这个函数可以为我们返回一个值

34
00:01:24,069 --> 00:01:27,075
假设我们想把两个数相乘

35
00:01:27,075 --> 00:01:29,079
我们想要写出一个函数来实现它

36
00:01:29,079 --> 00:01:33,015
我要做的第一件事就是在这里写一个叫返回值（return value)的东西

37
00:01:33,015 --> 00:01:35,073
这是这个函数会返回的类型

38
00:01:35,073 --> 00:01:37,047
因为我们把两个整数相乘

39
00:01:37,047 --> 00:01:37,080
当然

40
00:01:37,080 --> 00:01:39,009
将产生一个整数

41
00:01:39,009 --> 00:01:45,090
所以我们返回值是int，我将给这个函数一个名字，在本例中，叫Multiply，它会接受两个参数

42
00:01:45,090 --> 00:01:48,060
它们是我们想要相乘的数字

43
00:01:48,060 --> 00:01:51,054
我把它们叫做A和B，然后我将给函数一个身体

44
00:01:51,054 --> 00:01:54,060
它所要做的就是返回a*b

45
00:01:54,060 --> 00:01:55,002
 

46
00:01:55,002 --> 00:02:01,056
所以你可以看到我们这里有一个函数，它接受两个参数，都是整数，然后仅仅返回这两个数字的乘积

47
00:02:01,056 --> 00:02:03,081
我们并不一定要提供参数

48
00:02:03,081 --> 00:02:04,050
例如

49
00:02:04,050 --> 00:02:08,070
我可以不提供任何参数，然后返回5乘以8

50
00:02:08,070 --> 00:02:11,061
这仍然是一个返回一个整数的函数

51
00:02:11,061 --> 00:02:13,086
但它只是不取任何参数

52
00:02:13,086 --> 00:02:16,092
我们还可以告诉函数我们不想让它返回任何东西

53
00:02:16,092 --> 00:02:17,094
我们通过写一个void

54
00:02:17,094 --> 00:02:19,071
来作为它的返回类型

55
00:02:19,071 --> 00:02:21,023
void当然代表没东西，所以反过来

56
00:02:21,023 --> 00:02:21,024
 

57
00:02:21,024 --> 00:02:23,056
我们可以做类似于把结果打印到控制台

58
00:02:23,056 --> 00:02:23,057
 

59
00:02:26,052 --> 00:02:28,071
让我们回到原来的例子

60
00:02:28,071 --> 00:02:30,078
我们有int a和int b

61
00:02:30,078 --> 00:02:33,093
我们返回了这两个整数的乘积

62
00:02:33,093 --> 00:02:35,076
那么我们如何调用这个函数呢

63
00:02:35,076 --> 00:02:38,016
嗯，调用一个函数很简单

64
00:02:38,016 --> 00:02:40,068
让我们试着打印乘法的结果

65
00:02:40,068 --> 00:02:46,038
首先，我要声明一个变量来存储这个结果，所以我输入int result = Multiply()

66
00:02:46,038 --> 00:02:48,039
然后我们就用3和2

67
00:02:48,039 --> 00:02:56,097
这样做的结果就是用这两个参数来调用Multiply函数，然后把返回值，也就是a*b的结果

68
00:02:56,097 --> 00:02:58,056
存到这个result整型变量

69
00:02:58,056 --> 00:03:01,026
然后我们可以通过控制台输出这个result

70
00:03:01,026 --> 00:03:03,093
让我们按F5来运行我们的程序，当它build好后

71
00:03:03,093 --> 00:03:05,004
你可以看我们得到了6

72
00:03:05,004 --> 00:03:05,019
这个

73
00:03:05,019 --> 00:03:05,055
显然

74
00:03:05,055 --> 00:03:07,035
是3乘以2的结果

75
00:03:07,035 --> 00:03:08,057
让我们上一个蹬次

76
00:03:08,057 --> 00:03:13,023
假设我想要做一系列乘法，然后把它们都打印到控制台

77
00:03:13,023 --> 00:03:15,033
如果我在没有函数的情况下做类似的事情

78
00:03:15,033 --> 00:03:16,038
那么它看起来会很乱

79
00:03:16,038 --> 00:03:16,053
所以
So,

80
00:03:16,053 --> 00:03:17,019
例如
for example,

81
00:03:17,019 --> 00:03:18,060
我需要重复这段代码

82
00:03:18,060 --> 00:03:21,039
让我们去复制粘贴几次

83
00:03:21,039 --> 00:03:24,042
我把它们叫做result2和result3

84
00:03:24,042 --> 00:03:31,038
我们做8*5，和90*45，如果我运行我的程序，哦

85
00:03:31,038 --> 00:03:32,001
等一下

86
00:03:32,001 --> 00:03:33,051
我为啥得到一样的值

87
00:03:33,051 --> 00:03:33,096
哦看呀

88
00:03:33,096 --> 00:03:35,025
当我复制并粘贴这段代码时

89
00:03:35,025 --> 00:03:37,023
我忘记更改变量了

90
00:03:37,023 --> 00:03:39,012
你可能以为我是偶然犯的这个错误

91
00:03:39,012 --> 00:03:40,026
但实际上我是故意这么做的

92
00:03:40,026 --> 00:03:41,046
用以证明一些东西

93
00:03:41,046 --> 00:03:44,064
这种情况其实经常发生

94
00:03:44,064 --> 00:03:46,041
人们复制和粘贴代码块

95
00:03:46,041 --> 00:03:49,014
然后忘记改变一个小细节

96
00:03:49,014 --> 00:03:57,039
在某些情况下，你可能只是运行你的程序，甚至没有注意到不对，直到在之后某个地方造成错误

97
00:03:57,039 --> 00:04:01,026
然而，如果你为它创建一个函数，这种问题就非常容易解决

98
00:04:01,026 --> 00:04:04,023
让我们通过打印result2和result3来解决它

99
00:04:04,023 --> 00:04:05,022
如果我运行这个

100
00:04:05,022 --> 00:04:06,054
我们会得到正确的结果

101
00:04:06,054 --> 00:04:07,026
很好

102
00:04:07,026 --> 00:04:07,053
然而

103
00:04:07,053 --> 00:04:09,099
你可以看到我实际上是多次调用这个

104
00:04:09,099 --> 00:04:11,088
这有点烦

105
00:04:11,088 --> 00:04:12,006
就好像

106
00:04:12,006 --> 00:04:12,056
例如

107
00:04:12,056 --> 00:04:13,074
之后呢

108
00:04:13,074 --> 00:04:19,050
如果我决定用8乘以5来代替这个乘法函数

109
00:04:19,050 --> 00:04:19,089
看看这个

110
00:04:19,089 --> 00:04:22,023
我必须在每个地方替换它

111
00:04:22,023 --> 00:04:24,056
3*2， 90*45

112
00:04:24,056 --> 00:04:29,052
这。。我不想这么麻烦，所以先做乘法，然后打印结果

113
00:04:29,052 --> 00:04:31,041
让我们来为它写一个函数

114
00:04:31,041 --> 00:04:34,011
返回类型是void，因为它并不会返回什么给我们

115
00:04:34,011 --> 00:04:36,063
它只会执行我们要求它做的事情

116
00:04:36,063 --> 00:04:39,018
我们称它为”乘并打印“

117
00:04:39,018 --> 00:04:41,052
然后让我们看一下我们想要的参数

118
00:04:41,052 --> 00:04:44,091
所以这三段代码之间到底什么变化了？

119
00:04:44,091 --> 00:04:46,074
我们实际相乘的数

120
00:04:46,074 --> 00:04:47,064
仅此而已

121
00:04:47,064 --> 00:04:50,076
所以它们成为了我们函数的参数

122
00:04:50,076 --> 00:04:50,077
 

123
00:04:50,077 --> 00:04:56,001
到底这三段代码什么发生了变化，我们需要指定什么才能让这个函数执行我们想要的操作

124
00:04:56,001 --> 00:04:57,078
让我们写下我们的参数

125
00:04:57,078 --> 00:05:01,035
所以我们会接受两个int，a和b，你可以管它们叫任何东西

126
00:05:01,035 --> 00:05:02,063
但a和b听起来还是合理的

127
00:05:02,063 --> 00:05:02,064
 

128
00:05:02,064 --> 00:05:05,004
我们将把其中一段复制粘贴到这个函数中
we'll copy and paste one of these blocks into this function.

129
00:05:05,004 --> 00:05:05,079
这看起来很不错
This looks pretty good.

130
00:05:05,079 --> 00:05:17,022
当然，我将用我们的参数来替换3和2，这样我们就可以使用我们指定的参数来执行该函数里的惩罚运算了，这会导致a*b发生，然后打印结果到控制台

131
00:05:17,022 --> 00:05:17,079
所以现在

132
00:05:17,079 --> 00:05:25,065
我不需要写很多次这些，我只需要简单地调用MultiplyAndLog，并传入参数

133
00:05:25,065 --> 00:05:27,047
所以比如说3和2

134
00:05:27,047 --> 00:05:27,048
 

135
00:05:27,048 --> 00:05:29,052
然后是8和5

136
00:05:31,011 --> 00:05:33,092
然后是90和45

137
00:05:33,092 --> 00:05:33,093
 

138
00:05:35,085 --> 00:05:37,005
仅此而已，看呀
And that's it look at that,

139
00:05:37,005 --> 00:05:38,037
我可以这些代码都删掉

140
00:05:38,037 --> 00:05:40,014
这就是我们最后得到的样子，奈斯

141
00:05:40,014 --> 00:05:42,006
干净易读的程序

142
00:05:42,006 --> 00:05:44,004
如果我启动我的程序

143
00:05:44,004 --> 00:05:46,065
你可以看到我们得到了正确的值

144
00:05:46,065 --> 00:05:48,012
这是一个很简单的例子

145
00:05:48,012 --> 00:05:51,045
但我认为它很有效地证明了函数是非常重要的

146
00:05:51,045 --> 00:05:54,081
你的目标应该是把你的代码拆分成许多许多函数

147
00:05:54,081 --> 00:05:55,011
然而

148
00:05:55,011 --> 00:05:57,033
我想强调的一点是，不要太过分

149
00:05:57,033 --> 00:06:02,076
你不需要给每一行代码都准备一个函数，这对任何人都没有好处

150
00:06:02,076 --> 00:06:06,027
那样很难维护、你的代码看起来会很混乱很拥挤、

151
00:06:06,027 --> 00:06:10,065
而且那样其实会让你的代码更慢。我们每次调用函数时，星号~

152
00:06:10,065 --> 00:06:12,069
编译器会生成一个调用指令

153
00:06:12,069 --> 00:06:16,002
这基本上意味着，在一个运行的程序中

154
00:06:16,002 --> 00:06:17,082
为了让我们调用一个函数

155
00:06:17,082 --> 00:06:20,052
我们需要为这个函数创建一整个stack frame（栈框架）

156
00:06:20,052 --> 00:06:23,025
也就是说，我们得把参数之类的东西push（推）到栈上

157
00:06:23,025 --> 00:06:26,004
我们还需要把一个叫做返回地址的东西放到栈上

158
00:06:26,004 --> 00:06:34,050
然后我们其实要跳到我们程序的某个不同部分，以执行我们的函数里的指令，然后我们push的那个返回值

159
00:06:34,050 --> 00:06:37,056
我们需要返回给调用函数之前的地方

160
00:06:37,056 --> 00:06:38,019
所以这整个的

161
00:06:38,019 --> 00:06:41,040
为了执行函数指令而在内存中跳转来跳转去

162
00:06:41,040 --> 00:06:43,002
所有这些都需要时间

163
00:06:43,002 --> 00:06:44,022
所以它减慢了我们的程序

164
00:06:44,022 --> 00:06:44,037
现在

165
00:06:44,037 --> 00:06:51,033
我之前之所以说星号的原因是，因为这都是建立在假设编译器决定保留我们的函数作为一个函数而非内联（inline）它

166
00:06:51,033 --> 00:06:53,097
我们将在以后的视频中深入讨论inlining

167
00:06:53,097 --> 00:06:58,095
我之所以说这么多，是因为不想让你直接为每一行代码创建一个函数

168
00:06:58,095 --> 00:07:00,036
别太夸张了

169
00:07:00,036 --> 00:07:03,056
你需要一点经验来意识到你什么时候需要一个函数

170
00:07:03,056 --> 00:07:04,014
但基本上

171
00:07:04,014 --> 00:07:08,028
如果您看到自己正在多次做一个常见的任务，那么为它创建一个函数

172
00:07:08,028 --> 00:07:08,067
 

173
00:07:08,067 --> 00:07:12,056
函数的主要目的是防止代码重复

174
00:07:12,056 --> 00:07:16,077
我们不希望只是到处复制和粘贴代码

175
00:07:16,077 --> 00:07:16,098
现在

176
00:07:16,098 --> 00:07:18,072
如果我们再回到我们的代码

177
00:07:18,072 --> 00:07:21,093
你可能会注意到这个主函数有点奇怪

178
00:07:21,093 --> 00:07:24,012
它说他的返回值是int

179
00:07:24,012 --> 00:07:24,087
然而

180
00:07:24,087 --> 00:07:27,039
找不到return这个关键字

181
00:07:27,039 --> 00:07:29,088
很明显我没有返回任何东西

182
00:07:29,088 --> 00:07:32,010
如果我指定一个返回类型

183
00:07:32,010 --> 00:07:34,023
我真的需要返回一些东西吗

184
00:07:34,023 --> 00:07:36,090
让我们来试试看，在这个乘法函数中什么也不做

185
00:07:36,090 --> 00:07:38,070
按ctrl F7来编译该文件

186
00:07:38,070 --> 00:07:39,015
看看它

187
00:07:39,015 --> 00:07:41,097
我得到一个错误告诉我Multiply必须返回一个值

188
00:07:41,097 --> 00:07:45,009
因此带有返回类型的函数实际上需要返回值吗？

189
00:07:45,009 --> 00:07:46,041
答案是肯定的

190
00:07:46,041 --> 00:07:47,016
他们需要

191
00:07:47,016 --> 00:07:49,089
主函数实际上是一个特殊的函数

192
00:07:49,089 --> 00:07:55,056
主函数且只有主函数可以不用返回一个值

193
00:07:55,056 --> 00:07:57,033
如果你没有指定返回值

194
00:07:57,033 --> 00:07:59,079
它会自动假设你返回0

195
00:07:59,079 --> 00:08:02,013
所以它和我这样写的是一样的

196
00:08:02,013 --> 00:08:03,099
这只是现代c、c++版本的特点

197
00:08:03,099 --> 00:08:08,040
为了让你的代码更简洁。好玩的是

198
00:08:08,040 --> 00:08:09,056
所有这些必须返回一个值的规定

199
00:08:09,056 --> 00:08:13,014
实际上只适用于调试模式

200
00:08:13,014 --> 00:08:14,085
如果我们在release模式编译

201
00:08:14,085 --> 00:08:16,068
你会发现我们实际上并没有错误

202
00:08:16,068 --> 00:08:21,069
这并不是说我们在这里做的是正确的,因为如果拿那个返回值做其他事

203
00:08:21,069 --> 00:08:23,088
会得到未定义行为

204
00:08:23,088 --> 00:08:26,016
只是编译器并没有对我们大喊而已

205
00:08:26,016 --> 00:08:26,070
然而

206
00:08:26,070 --> 00:08:27,054
在调试模式下

207
00:08:27,054 --> 00:08:29,046
当特定的调试编译标记（flags）被激活时

208
00:08:29,046 --> 00:08:33,099
我们将会得错误，它将帮助我们调试代码

209
00:08:33,099 --> 00:08:39,039
因为在任何时候你都不应该写一个函数，说它会返回什么，但是并没有返回

210
00:08:39,039 --> 00:08:42,030
ok，这是对函数的基本介绍

211
00:08:42,030 --> 00:08:43,074
函数非常有用

212
00:08:43,074 --> 00:08:46,020
我将会在未来写更多函数

213
00:08:46,020 --> 00:08:48,084
每个程序都是由一系列函数组成的

214
00:08:48,084 --> 00:08:50,067
非常重要的东西

215
00:08:50,067 --> 00:08:53,010
如果你不认为你完全理解函数是如何工作的

216
00:08:53,010 --> 00:08:53,073
别担心

217
00:08:53,073 --> 00:08:54,087
因为在整个系列中

218
00:08:54,087 --> 00:08:57,087
我们将会运行很多函数，你将会习惯它

219
00:08:57,087 --> 00:08:58,095
最好的学习方法当然是

220
00:08:58,095 --> 00:08:59,025
 

221
00:08:59,025 --> 00:08:59,097
练习

222
00:08:59,097 --> 00:09:03,063
我们还通常将函数拆分为声明和定义

223
00:09:03,063 --> 00:09:04,041
所以声明
so declarations,

224
00:09:04,041 --> 00:09:07,014
通常会存在头文件，而定义

225
00:09:07,014 --> 00:09:08,043
会写在翻译单元里

226
00:09:08,043 --> 00:09:09,045
或者说cpp文件里

227
00:09:09,045 --> 00:09:12,021
然后我将制作一个专门讲头文件的视频

228
00:09:12,021 --> 00:09:16,026
我们将在那个视频中讲到头文件中到函数声明

229
00:09:16,026 --> 00:09:16,098
（后面不翻译啦）
for any of you guys.

230
00:09:16,098 --> 00:09:18,036
I hope you enjoyed this episode.

231
00:09:18,036 --> 00:09:18,084
If you did,

232
00:09:18,084 --> 00:09:19,089
please hit a like button.

233
00:09:19,089 --> 00:09:22,011
Don't forget to follow me on Twitter and Instagram.

234
00:09:22,011 --> 00:09:26,004
And if you really enjoy this video and you want to see drafts of future videos early,

235
00:09:26,004 --> 00:09:28,080
as well as discuss what actually goes into these videos,

236
00:09:28,080 --> 00:09:31,041
you can support me on patriot on the link between description below.

237
00:09:31,041 --> 00:09:32,022
But until next time,

238
00:09:32,022 --> 00:09:32,067
guys,

239
00:09:32,067 --> 00:09:33,030
good bye.

