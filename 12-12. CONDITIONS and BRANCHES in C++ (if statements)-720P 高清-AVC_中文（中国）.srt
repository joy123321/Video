1
00:00:00,003 --> 00:00:01,088
大家好我是cherno

2
00:00:02,015 --> 00:00:05,038
欢迎重新回到我的C++系列教程   

3
00:00:05,038 --> 00:00:07,085
今天就让我们来看看条件语句  

4
00:00:07,085 --> 00:00:13,048
换句话说就是if语句和if-else语句就是全部内容了

5
00:00:13,050 --> 00:00:15,012
我知道对于大部分的观众来说

6
00:00:15,012 --> 00:00:20,038
你们可能觉得你们已经知道所有关于if还有它在C++里的分支行为的知识了

7
00:00:20,038 --> 00:00:22,077
但是我仍然支持大家继续看这个视频

8
00:00:22,077 --> 00:00:24,067
因为你可能会学习到一些新的知识

9
00:00:24,067 --> 00:00:28,010
我实际上已经准备在条件结构如和在C++中工作这一方面讲得更加深入一些

10
00:00:28,010 --> 00:00:29,017
所以很值得看看

11
00:00:29,017 --> 00:00:33,095
好，条件语句、if句式或者分支结构到底意味着什么

12
00:00:33,095 --> 00:00:35,057
这些都是什么？

13
00:00:35,057 --> 00:00:41,010
基础上来说总有某些时候，当代码需要去评估某个值

14
00:00:41,014 --> 00:00:45,075
来决定我们下一步的执行操作

15
00:00:46,003 --> 00:00:49,078
所以举个例子 那就让我们假设有一个变量X并且赋值为5

16
00:00:49,078 --> 00:00:54,025
我们能够写出当值为5的情况下而做出某些特定操作的代码

17
00:00:54,025 --> 00:00:56,078
这就是条件结构存在的意义了

18
00:00:56,078 --> 00:01:00,035
条件结构就是 当X等于5时 我们可以根据这个情况

19
00:01:00,035 --> 00:01:02,083
跳转到我们所需要的分支

20
00:01:02,083 --> 00:01:05,085
当我们写if句式的时候 有两件事会发生

21
00:01:05,085 --> 00:01:09,043
当我们跑代码的时候，就会有对实际条件情况的比较

22
00:01:09,043 --> 00:01:12,040
然后，还有取决于比较结果的分支

23
00:01:12,040 --> 00:01:22,053
换句话说 我们的条件为真我们就需要跳转到 我们的源代码中的某一部分  如果条件为假我们就得把代码跳转到我们源代码中的另一部分

24
00:01:22,053 --> 00:01:24,025
当然我说的是源代码

25
00:01:24,025 --> 00:01:27,035
但是在运行的应用中，这可能就得说成是机器指令

26
00:01:27,035 --> 00:01:32,035
所以，也可以说是我们跳转到了机器码或者cpu指令的分支中

27
00:01:32,035 --> 00:01:34,030
或者跳转到另一部分的CPU指令当中

28
00:01:34,030 --> 00:01:39,085
当我们开启一个应用，一个完整的应用，伴随着它的诸多模组就加载到了内存中

29
00:01:39,085 --> 00:01:44,085
所以，这时候所有组成我们程序的所有代码都储存到内存中

30
00:01:44,085 --> 00:01:49,005
当我们有一个条件指令指向一个分支时，我们就是在告诉电脑

31
00:01:49,005 --> 00:01:50,090
嘿，快跳转至这个部分的内存

32
00:01:50,090 --> 00:01:53,030
然后开始执行我们的指令

33
00:01:53,030 --> 00:01:56,080
因为这些跳转和分支

34
00:01:56,080 --> 00:02:01,080
这确实比我所说的难那么一些 这还有一些值得探索的

35
00:02:01,080 --> 00:02:03,054
举个例子

36
00:02:03,054 --> 00:02:09,077
我们比较条件、跳转到内存中的其他部分然后执行指令

37
00:02:09,077 --> 00:02:11,085
意味着

38
00:02:11,085 --> 00:02:16,000
如果我们的语句和分支分布在内存距离较远的地方

39
00:02:16,000 --> 00:02:17,075
并且当我们打算写一些高效的代码时

40
00:02:17,075 --> 00:02:20,045
我们就有可能决定不去使用if句式

41
00:02:20,045 --> 00:02:25,025
实际上，很多优化过的代码会尤其避免分支结构，避免比较

42
00:02:25,025 --> 00:02:28,010
因为那么做会让代码变慢

43
00:02:28,010 --> 00:02:35,015
在这个系列的最后我们会看一些 将分支结构去除的优化例程

44
00:02:35,015 --> 00:02:37,005
但是，现在为时过早

45
00:02:37,005 --> 00:02:39,035
我想说的是我对这个系列有很多计划

46
00:02:39,035 --> 00:02:41,031
所以各位，敬请期待

47
00:02:41,031 --> 00:02:44,069
无论如何，不想讲得太复杂

48
00:02:44,069 --> 00:02:52,023
记住条件结构就是当条件为真就跳转并执行代码的某一部分

49
00:02:52,023 --> 00:02:54,062
这就是基础的全部内容

50
00:02:54,062 --> 00:02:57,038
现在给大家展示例子

51
00:02:57,038 --> 00:02:59,010
我用这个这个非常基础的应用给大家展示

52
00:02:59,010 --> 00:03:01,010
在前几集中我们也用的是这个VS IDE

53
00:03:01,010 --> 00:03:03,012
我们开始吧

54
00:03:03,012 --> 00:03:05,085
拿X作为一个例子

55
00:03:05,085 --> 00:03:08,095
声明它并赋值5然后

56
00:03:08,095 --> 00:03:12,095
我们现在想当X==5时就输出hello world

57
00:03:12,095 --> 00:03:15,000
所以我可以做的就是输入if

58
00:03:15,000 --> 00:03:17,010
然后键入条件

59
00:03:17,012 --> 00:03:19,048
为了能让功能实现

60
00:03:19,048 --> 00:03:22,090
也为了我们确实能检查X是否等于5

61
00:03:22,090 --> 00:03:25,070
我们就不得不执行一种叫做比较的操作

62
00:03:25,070 --> 00:03:29,065
也就是拿一个值和另外的一个值比较

63
00:03:29,065 --> 00:03:33,000
这个实际上是一个布尔类型的语句

64
00:03:33,000 --> 00:03:35,073
也就是说一个表达真与假的语句

65
00:03:35,073 --> 00:03:38,005
X可能是5也可能不是

66
00:03:38,005 --> 00:03:39,080
所以通过这个就可以知道其真假

67
00:03:39,080 --> 00:03:43,090
如果我们想要存储一个布尔语句，我们知道我们可以用布尔数据类型的变量来存储

68
00:03:43,090 --> 00:03:50,065
所以我们就键入变量comparisonResult = x == 5

69
00:03:50,065 --> 00:03:55,065
在这的运算符是双等号被称作等于号

70
00:03:55,065 --> 00:03:59,015
它是用来确认x是否是等于5的

71
00:03:59,015 --> 00:04:02,085
如果等于5就会返回真

72
00:04:02,085 --> 00:04:06,045
如果不是5就会返回假

73
00:04:06,045 --> 00:04:09,000
所以一旦这行代码得到执行

74
00:04:09,000 --> 00:04:11,038
比较的结果就会使真或者假

75
00:04:11,038 --> 00:04:12,077
这取决于x的值

76
00:04:12,077 --> 00:04:17,077
这个运算符是这个含义的原因是它在C的标准库中已经被加载过了

77
00:04:17,077 --> 00:04:26,046
某人写了一个函数，可以接纳两个整数，然后从内存中调出整数 进行比较确保是否相等

78
00:04:26,046 --> 00:04:30,008
如果是返回真，这就是这个==的功能的全部

79
00:04:30,008 --> 00:04:35,008
你们所见的所有运算符，在C&C++里的都不是什么魔术之类的

80
00:04:35,008 --> 00:04:40,008
他们已经在某种方式上被实施执行过了，就像在本例中的标准库一样

81
00:04:40,008 --> 00:04:42,085
它们才能以整数的形式展现

82
00:04:42,085 --> 00:04:48,064
大部分原始的数据结构，实际上在检查两个整数是否相等的时候

83
00:04:48,064 --> 00:04:51,047
你其实是讲表示他们的四个字节给抓取出来

84
00:04:51,047 --> 00:04:53,089
然后再逐字节逐位地进行比较

85
00:04:53,089 --> 00:04:57,038
在内存中对应位的二进制数都得相同

86
00:04:57,038 --> 00:04:58,083
才能是相等的

87
00:04:58,083 --> 00:05:03,083
所以最后我们才能使用这个if语句中的比较结果  

88
00:05:03,083 --> 00:05:06,015
如果我们想让条件为真 时执行某个分支

89
00:05:06,015 --> 00:05:08,015
我们有两种写法

90
00:05:08,015 --> 00:05:10,023
我们可以写if(comparisonResult==true)

91
00:05:10,023 --> 00:05:12,085
然而这没什么必要

92
00:05:12,085 --> 00:05:21,031
因为如果我们就写成if(comparisonResult)也能得到相同的效果

93
00:05:21,031 --> 00:05:25,038
简而言之就是只要comparisonResult非真那么 if句式的内容就不会运行

94
00:05:25,038 --> 00:05:27,090
然后呢我们就得在{}内的主体内写上一些详尽的代码

95
00:05:27,090 --> 00:05:31,010
这就是你分支要跳转到的地方

96
00:05:31,010 --> 00:05:33,090
就是当你的条件为真时，你希望电脑能跑的代码 

97
00:05:33,090 --> 00:05:36,023
所以呢我们在这里先键入{}

98
00:05:36,023 --> 00:05:38,035
然后输入log函数，很好

99
00:05:38,035 --> 00:05:41,015
我们现在已经创造了一个分支

100
00:05:41,015 --> 00:05:42,050
所以，如果comparisonResult这个变量是真

101
00:05:42,050 --> 00:05:44,050
我们就要输出hello world到控制台

102
00:05:44,050 --> 00:05:45,090
否者就不要输出

103
00:05:45,090 --> 00:05:47,060
然后呢，还有一些有意思的事

104
00:05:47,060 --> 00:05:51,030
即使是在这段我们写的短小的代码也可以与之相关

105
00:05:51,030 --> 00:05:54,030
因为他们实在是无处不在

106
00:05:54,030 --> 00:05:57,030
我们先运行一下代码看看会发生什么再说

107
00:05:57,030 --> 00:05:59,050
如果我们敲击F5它就会逐行运行

108
00:05:59,050 --> 00:06:02,050
现在开始运行我的程序

109
00:06:02,050 --> 00:06:04,050
你可以看到我得到了hello world的输出

110
00:06:04,050 --> 00:06:07,020
然而如果我把x改成6

111
00:06:07,020 --> 00:06:09,030
我再按F5，就什么也不会发生

112
00:06:09,030 --> 00:06:11,080
如果我们在这放置一个断点

113
00:06:11,080 --> 00:06:14,010
我在上期视频中讲到过了断点和debug

114
00:06:14,010 --> 00:06:15,050
如果你们还没去看过

115
00:06:15,050 --> 00:06:17,050
你们也想去看看的话 

116
00:06:17,050 --> 00:06:19,080
在电脑屏幕的附近必定有相应的视频或这链接什么的

117
00:06:19,080 --> 00:06:23,000
我们会用到很多关于断点和debug的知识

118
00:06:23,000 --> 00:06:23,090
所以你们还是去看看吧

119
00:06:23,090 --> 00:06:26,010
在设置好断点的情况下，我按下F5

120
00:06:26,010 --> 00:06:28,050
先把这个内存管理窗口关了好了

121
00:06:28,050 --> 00:06:30,060
接下来我要按F10了

122
00:06:30,060 --> 00:06:34,000
我们可以看到x等于6这么一个情况

123
00:06:34,000 --> 00:06:37,010
在这个情况下x==5就返回了假

124
00:06:37,010 --> 00:06:39,025
comparisonResult将会是假

125
00:06:39,025 --> 00:06:43,012
如果我在这直接按下F10

126
00:06:43,012 --> 00:06:44,060
if语句就会直接评估条件

127
00:06:44,060 --> 00:06:48,045
然后你可以看到它直接跳到了这cin.get()

128
00:06:48,045 --> 00:06:50,090
这行代码从来没被运行过因为

129
00:06:50,090 --> 00:06:57,090
只有当comparisonResult是真的时候才输出helloworld

130
00:06:57,090 --> 00:07:02,010
如果我们想再深入地了解一点背后运作的机理和

131
00:07:02,010 --> 00:07:03,085
实际上在工作的CPU指令知识

132
00:07:03,085 --> 00:07:07,075
我们可以将其编译成汇编语言，再来检查这些汇编语言

133
00:07:07,089 --> 00:07:09,050
然而还有一件很重要的事 

134
00:07:09,050 --> 00:07:12,020
我们可以做一件类似于debug中的部分工作的事

135
00:07:12,020 --> 00:07:14,025
我们使用VS中的disassemblely工具来处理目前这些代码 

136
00:07:14,025 --> 00:07:16,040
如果我们在设定好断点的情况下按下F5来运行我们的程序

137
00:07:16,040 --> 00:07:18,050
我们可以做的就是在这点击鼠标

138
00:07:18,050 --> 00:07:20,050
这是我们的软件产生的

139
00:07:20,050 --> 00:07:23,045
我可以右键这里然后选择go to disassembly(ctrl+G)然后就转到了这个界面


140
00:07:23,045 --> 00:07:25,060
然后就转到了这个界面

141
00:07:25,060 --> 00:07:30,000
在这我们既有源代码又有与之相应的汇编语言

142
00:07:30,000 --> 00:07:32,070
换句话说我们的编译器

143
00:07:32,070 --> 00:07:35,025
将这行源代码转化成了这一行

144
00:07:35,025 --> 00:07:39,040
这一行又编译成这些汇编语言

145
00:07:39,040 --> 00:07:42,045
我们也可以逐行来运行这些汇编语言

146
00:07:42,045 --> 00:07:45,070
可以看看在我们CPU的寄存器里都存储了什么

147
00:07:45,070 --> 00:07:53,015
这挺叼的，并且很有用，特别是当你想要去debug一些你没法直接看出问题的源代码

148
00:07:53,015 --> 00:07:56,035
也可以debug一些CPU指令，当然这简直是场恶梦

149
00:07:56,035 --> 00:07:59,015
btw，大家尽可能的避免去debug汇编语言吧

150
00:07:59,015 --> 00:08:03,040
不过用来快速查看编译器产生了什么样的代码，还是蛮有用的

151
00:08:03,040 --> 00:08:07,090
而不是去将所有的输出都放到一个文件里，然后几乎可以填满我的家

152
00:08:07,090 --> 00:08:14,055
这不是C++编译器视频所以回到我们前面说的地方

153
00:08:14,055 --> 00:08:18,050
你们可以看到的第一件事 是在这儿发生的

154
00:08:18,050 --> 00:08:20,060
我不是要花半个小时的时间的时间来教你们汇编语言

155
00:08:20,060 --> 00:08:24,060
但我确实很想在以后做几期关于汇编的视频

156
00:08:24,060 --> 00:08:28,020
如果你们想要的话，就在下方留下评论吧

157
00:08:28,020 --> 00:08:29,065
因为确实有很有人来问我关于这方面的问题

158
00:08:29,065 --> 00:08:33,045
但是现在我的确不想在这方面发太多的时间

159
00:08:33,045 --> 00:08:34,050
来解释每件事是怎么工作的

160
00:08:34,050 --> 00:08:35,000
所以我在这解释一下

161
00:08:35,000 --> 00:08:37,000
如果你们感兴趣并且想要学习更多知识

162
00:08:37,000 --> 00:08:38,024
你可以自行上网学习

163
00:08:38,024 --> 00:08:39,025
或者留下评论吧

164
00:08:39,027 --> 00:08:41,055
某天我可能就会尝试去做一个视频

165
00:08:41,055 --> 00:08:43,025
我们再来看看这些代码

166
00:08:43,025 --> 00:08:47,010
在这发生的是我们把一个值载入到一个寄存器中

167
00:08:47,010 --> 00:08:49,085
这个MOVE指令就意味着移动

168
00:08:49,085 --> 00:08:53,010
我们将6移动至寄存器，对吧？

169
00:08:53,023 --> 00:08:56,025
你可以把它当作它把变量设置成了6

170
00:08:56,025 --> 00:08:57,056
如果我们在这按下F10

171
00:08:57,056 --> 00:08:59,015
我们就会到下一条指令

172
00:08:59,015 --> 00:09:01,085
这个就是我们提到的布尔声明

173
00:09:01,085 --> 00:09:07,070
我们现在在做的就是 我们将5给加载到同样的寄存器中去

174
00:09:07,070 --> 00:09:12,000
这很有趣，因为现在编译器要来整点漂亮的代码活

175
00:09:12,000 --> 00:09:15,065
我们继续往下读 就可以看到JNE语句

176
00:09:15,065 --> 00:09:17,075
它的意思是如果不等 就跳转(jump not equal)

177
00:09:17,075 --> 00:09:21,065
也就是如果比较结果是假 就跳转

178
00:09:21,065 --> 00:09:25,005
很显然这个CMP语句就是在比较两个值，5和6

179
00:09:25,023 --> 00:09:26,050
如果他们不相等

180
00:09:26,054 --> 00:09:28,070
我们就跳转到这个内存地址 

181
00:09:28,091 --> 00:09:33,020
这个内存地址就是这里写的这个值01B59B7

182
00:09:33,042 --> 00:09:36,080
我们看看这个地址9B7

183
00:09:36,080 --> 00:09:39,005
就在这下方这行

184
00:09:39,005 --> 00:09:41,040
如果他们不相等我们就要跳转到这一行

185
00:09:41,040 --> 00:09:43,020
现在我们都知道是不相等的

186
00:09:43,020 --> 00:09:47,040
所以我按下F10你可以看到我们的指令指针(IP)

187
00:09:47,040 --> 00:09:50,050
这个黄色的箭头就是我们的电脑正在执行的位置

188
00:09:50,050 --> 00:09:54,000
现在跳转到这个内存地址来执行下一条指令

189
00:09:54,000 --> 00:09:59,000
这条指令要将某个值，在这里是0，载入寄存器中

190
00:09:59,000 --> 00:10:01,097
这个寄存器叫做EBP

191
00:10:01,097 --> 00:10:04,097
实质是寄存器EBP减去某个补偿(offset)

192
00:10:05,013 --> 00:10:07,045
我们现在要把值0给加载进去

193
00:10:07,045 --> 00:10:10,025
现在我们可以再来讲讲布尔类型了

194
00:10:10,025 --> 00:10:13,075
不知道大家有没有看过我那期关于变量和C++的视频

195
00:10:13,075 --> 00:10:15,003
没看的可以去看看

196
00:10:15,003 --> 00:10:19,005
我说过这样一件事，布尔类型本质上是一种一个字节(8位)长度的数据类型

197
00:10:19,005 --> 00:10:23,040
就和其他数据类型一样，在C++里根本没有真或者假的概念

198
00:10:23,040 --> 00:10:25,010
所以布尔类型是怎么工作的呢？

199
00:10:25,010 --> 00:10:28,070
如果值是0那么就是假

200
00:10:28,070 --> 00:10:32,062
如果值是其他任何数，那就是真

201
00:10:32,062 --> 00:10:33,090
我们只是在处理数字而已

202
00:10:33,090 --> 00:10:35,003
计算机在这儿处理数字

203
00:10:35,003 --> 00:10:39,028
但是因为我们在可编址内存获取了一个相当庞大的空间

204
00:10:39,028 --> 00:10:43,017
如果我们申请布尔类型就会占用一个字节

205
00:10:43,017 --> 00:10:47,038
我们也没必要去确认有一位被置1

206
00:10:47,038 --> 00:10:50,017
所以就像在使用时那样

207
00:10:50,017 --> 00:10:52,065
只要不是0就会被认作是真

208
00:10:52,065 --> 00:10:55,020
当然，如果我们只处理一位的话

209
00:10:55,020 --> 00:10:57,060
我们也就只有两个可能的值0和1

210
00:10:57,060 --> 00:10:59,040
如果是0就是假

211
00:10:59,040 --> 00:11:00,075
如果是1就是真

212
00:11:00,075 --> 00:11:03,038
既然我们有一个这么大的空间

213
00:11:03,038 --> 00:11:05,062
我们可以非常自信的说

214
00:11:05,062 --> 00:11:08,008
即使是100，这也将会是真

215
00:11:08,008 --> 00:11:10,078
当然，是0 ，肯定被判做是假

216
00:11:10,085 --> 00:11:15,028
尽管如此，在这儿发生的就是我们将0载入到这个寄存器中

217
00:11:15,028 --> 00:11:19,010
所以才能将0分配到那个布尔类型的变量之中

218
00:11:19,010 --> 00:11:23,088
所以假就是0 真在通常情况下是1 

219
00:11:23,088 --> 00:11:28,040
虽然我们必须得把值输入进去 可以是1

220
00:11:28,040 --> 00:11:34,055
然而，也没说非得去填1，可以是很多数

221
00:11:34,055 --> 00:11:37,030
但是假的的确确就是0

222
00:11:37,030 --> 00:11:39,060
真也可以是1

223
00:11:39,060 --> 00:11:44,000
这个MOVE指令将0载入了那个内容为假的内存块

224
00:11:44,000 --> 00:11:50,072
这也就是把那个布尔变量给设置成了假，因为比较失败了 

225
00:11:50,076 --> 00:11:51,095
我们接着往下看

226
00:11:51,095 --> 00:11:53,062
这里有一些其他类型的代码

227
00:11:53,062 --> 00:11:55,035
我们不需要太关心它们

228
00:11:55,035 --> 00:11:58,000
我们来看看if语句编译出来的汇编语言

229
00:11:58,000 --> 00:12:00,025
所以我们在if语句中都做了什么

230
00:12:00,025 --> 00:12:03,010
同样，我们再次把某些值载入到EAX寄存器里

231
00:12:03,010 --> 00:12:06,095
我们来测试一下这个EAX寄存器是否有传递我们的条件

232
00:12:06,095 --> 00:12:12,033
这里这个test指令 对两个操作数执行“与”操作 并把结果保存到第一个寄存器中

233
00:12:12,033 --> 00:12:14,080
我不想在这方面讲的太深入

234
00:12:14,080 --> 00:12:17,050
简单来说 如果这个test操作成功了

235
00:12:17,050 --> 00:12:19,085
接下来就会进行JE(jump equal)操作

236
00:12:19,085 --> 00:12:22,080
换句话说 就是如果test操作是真

237
00:12:22,080 --> 00:12:27,045
那么我们就要跳转到地址尾为90F的内存块

238
00:12:27,045 --> 00:12:28,038
这其实是这行代码所在的地址

239
00:12:28,038 --> 00:12:30,095
那么我们会直接跳过log函数的代码段

240
00:12:30,095 --> 00:12:36,092
如果不是这个情况 我们就不跳过这个代码段

241
00:12:36,092 --> 00:12:40,040
这不是个通常的JUMP命令这是，不是JMP

242
00:12:40,040 --> 00:12:41,065
这是JE

243
00:12:41,065 --> 00:12:43,053
所以这是个条件型的跳转指令

244
00:12:43,053 --> 00:12:46,017
所以如果比较失败了

245
00:12:46,017 --> 00:12:47,080
我们就会到下面一行

246
00:12:47,080 --> 00:12:50,042
这里又来了新的一条CPU指令

247
00:12:50,042 --> 00:12:52,042
做了如下的一点事

248
00:12:52,042 --> 00:12:55,003
然而我们已经知道这个测试就要成功了

249
00:12:55,003 --> 00:12:56,083
因为这个comparisonResult是假的

250
00:12:56,083 --> 00:13:00,070
所以如果我们按下F10 你可以看到我们就跳到了这里

251
00:13:00,070 --> 00:13:03,083
我们继续运行我们的程序，一切正常

252
00:13:03,083 --> 00:13:08,050
这些就是稍微深入地讨论了一下在计算机里实际上发生的事

253
00:13:08,050 --> 00:13:12,053
记住，我在debug模式下编译并且运行这个代码

254
00:13:12,053 --> 00:13:15,095
这意味着这并没有优化我们的代码

255
00:13:15,095 --> 00:13:20,097
所以如果我们再重新看看这个这个代码，这里其实有很多都是可以被简化的

256
00:13:20,097 --> 00:13:24,005
编译器知道这个变量x被赋值为6

257
00:13:24,005 --> 00:13:25,095
然后再拿它和5作比较

258
00:13:25,095 --> 00:13:27,035
它完全可以自己完成这个工作

259
00:13:27,035 --> 00:13:29,005
没有必要在运行的时候再来比较

260
00:13:29,005 --> 00:13:33,017
完全可以在编译的时候来解决这个问题

261
00:13:33,017 --> 00:13:35,080
这种被称为常数折迭(constant folding)的技术就出现了

262
00:13:35,080 --> 00:13:38,000
它会把这些都转到一个常变量中

263
00:13:38,000 --> 00:13:41,000
因为这些常量都会在编译时被知晓

264
00:13:41,000 --> 00:13:46,033
就可以摆脱这个comparisonResult还有这个if语句

265
00:13:46,033 --> 00:13:48,088
只留下这个std::cin.get()

266
00:13:48,088 --> 00:13:52,053
他就会直接移除6-11行的所有内容

267
00:13:52,053 --> 00:13:54,067
因为他们没有运行的必要

268
00:13:54,067 --> 00:13:58,083
所以为什么要编译他们？为什么要在运行时做条件检查？

269
00:13:58,083 --> 00:14:00,050
仅仅是在浪费时间而已

270
00:14:00,050 --> 00:14:01,083
我们清楚地知道我们不需要它

271
00:14:01,083 --> 00:14:04,010
记住，如果你想在这一方面搞得比较清楚

272
00:14:04,010 --> 00:14:06,057
通过查看disassemblely来弄懂这些事物都是怎么工作的

273
00:14:06,057 --> 00:14:10,012
确保你是在debug模式下 确保尽可能地不去优化代码

274
00:14:10,012 --> 00:14:14,028
因为如果你不这么做 编译器就会做它该做的事

275
00:14:14,041 --> 00:14:15,075
表演一些魔法

276
00:14:15,075 --> 00:14:16,088
然后你觉会被虐

277
00:14:16,088 --> 00:14:18,033
好，我们重新回到这个

278
00:14:18,033 --> 00:14:21,030
我们知道这个comparisonResult是一个布尔类型

279
00:14:21,030 --> 00:14:25,010
布尔类型变量简单来说就是个整数，对吧？

280
00:14:25,010 --> 00:14:26,092
是0就是假

281
00:14:26,092 --> 00:14:28,040
1就是真

282
00:14:28,040 --> 00:14:30,033
所以if语句究竟在做什么

283
00:14:30,033 --> 00:14:33,028
它在看条件是不是数字0

284
00:14:33,028 --> 00:14:38,053
如果是0，它就不去运行后面的语句了

285
00:14:38,053 --> 00:14:41,072
然而如果不是0，比如说是1

286
00:14:41,072 --> 00:14:43,080
他就会跳入到后面这一部分

287
00:14:43,080 --> 00:14:45,047
这就是这些玩意工作的原因

288
00:14:45,047 --> 00:14:48,035
我们没有必要去写==true

289
00:14:48,035 --> 00:14:52,000
因为我们没必要去检查这是否等于1或者等于true

290
00:14:52,000 --> 00:14:53,005
或者之类的东西

291
00:14:53,010 --> 00:14:57,033
我们可以简单的检查这个东西是否为0 这就是它所做的

292
00:14:57,033 --> 00:15:01,025
这就像是在说 嘿 看看这个comparisonResult存储的内存块

293
00:15:01,025 --> 00:15:03,080
里面存的是不是0啊

294
00:15:03,080 --> 00:15:06,038
如果不是0，就执行下面这个代码

295
00:15:06,039 --> 00:15:07,062
如果是0，就别

296
00:15:07,062 --> 00:15:10,008
这就是if语句的重点所在

297
00:15:10,010 --> 00:15:12,030
举个例子 如果我们写if(1) 

298
00:15:12,030 --> 00:15:16,028
然后运行我的代码，代码编译得很流畅

299
00:15:16,028 --> 00:15:19,067
你就会看到hello world被输出到了屏幕上

300
00:15:19,067 --> 00:15:23,010
如果我输入if(0)，它就不会被输出到屏幕上

301
00:15:23,010 --> 00:15:24,095
非常简单，我们都已经懂了

302
00:15:24,095 --> 00:15:28,050
当然，有了comparisonResult我们都不用另外声明变量来存储

303
00:15:28,050 --> 00:15:32,097
我声明了x是因为 我想给大家展示 这个条件是一个 布尔类型

304
00:15:32,097 --> 00:15:39,067
你们可以在这写成x==5 这可以简化你的代码一些

305
00:15:39,067 --> 00:15:42,015
如果我们的if语句后 只有一个语句

306
00:15:42,015 --> 00:15:45,000
我们连大括号都不要

307
00:15:45,000 --> 00:15:47,038
我可以写成这样子  这样也是ok的

308
00:15:47,038 --> 00:15:49,025
你还可以更改一下位置

309
00:15:49,025 --> 00:15:50,078
有的人喜欢把它们写在同一行

310
00:15:50,078 --> 00:15:51,097
我个人是不喜欢这么写的

311
00:15:51,097 --> 00:15:58,017
举个例子，因为当你想要进行debug的时候，你把断点放在这儿

312
00:15:58,017 --> 00:16:05,015
就无法弄清楚现在是在执行比较还是在log函数

313
00:16:05,015 --> 00:16:07,095
如果我按F10，它就跳过了 我不知道发生了啥

314
00:16:07,095 --> 00:16:13,080
然而 如果我把他们分成两行 我就可以检查具体情况了

315
00:16:13,080 --> 00:16:16,035
你可以看到在 如果我按F10，没有经过那一行

316
00:16:16,035 --> 00:16:18,003
那行没有被执行

317
00:16:18,003 --> 00:16:21,038
简单实在 因为布尔类型就是简单的数值

318
00:16:21,038 --> 00:16:25,003
也因为if语句只检测数字

319
00:16:25,003 --> 00:16:27,080
你可以用if做一点看起来蛮叼的事

320
00:16:27,085 --> 00:16:36,095
比如，我可以写if(x) 然后如果我运行代码就会去检查x是0与否

321
00:16:36,095 --> 00:16:41,067
当然，x是6，所以如我我按F10

322
00:16:41,067 --> 00:16:46,085
我们就可以跳转到log函数

323
00:16:46,085 --> 00:16:48,072
这个技巧可以应用在指针上

324
00:16:48,072 --> 00:16:51,040
如果我们想要去检查一个指针是否是null

325
00:16:51,040 --> 00:16:52,030
null当然也是0

326
00:16:52,030 --> 00:16:55,017
我们可以把这个指针

327
00:16:55,017 --> 00:16:57,083
放入if语句的条件中 就像这样

328
00:16:57,083 --> 00:17:10,045
举个例子，如果我有一个指针，const char* pointer = “hello”; （继续写代码）

329
00:17:10,045 --> 00:17:12,015
如果我运行这段代码

330
00:17:12,015 --> 00:17:14,028
你可以发现pointer被置成了某些值 

331
00:17:14,028 --> 00:17:15,010
而且不是null

332
00:17:15,012 --> 00:17:18,093
因为我们可以将它打印出来

333
00:17:18,093 --> 00:17:22,010
假如它是等于空指针(nullptr)

334
00:17:22,010 --> 00:17:27,055
你会发现这行代码就不运行了

335
00:17:27,055 --> 00:17:32,022
所以不要写pointer!=nullpter

336
00:17:32,022 --> 00:17:33,072
我们可以写得更简洁一点

337
00:17:33,072 --> 00:17:36,072
这也是一种个人代码风格吧

338
00:17:36,072 --> 00:17:39,007
有些人就是喜欢写得详细一点

339
00:17:39,007 --> 00:17:40,080
他们认为这样能让代码的可读性更好

340
00:17:40,080 --> 00:17:42,050
我个人不是太感冒

341
00:17:42,050 --> 00:17:43,055
我通常是这样写

342
00:17:43,055 --> 00:17:46,012
因为对我来说，这样更有意义吧

343
00:17:46,012 --> 00:17:48,060
这个ptr也是有效的值

344
00:17:48,060 --> 00:17:49,082
就这么写吧

345
00:17:49,082 --> 00:17:51,097
这样看起来干净整洁

346
00:17:51,097 --> 00:17:56,003
有些能在C++里做的事并不能在别的语言中做到比如java/C#

347
00:17:56,003 --> 00:18:01,055
它俩看起来可明确，但是C++本来就是一种更加难懂的语言，对吧？

348
00:18:01,055 --> 00:18:02,047
反正什么事都有可能发生

349
00:18:02,047 --> 00:18:05,053
现在，如果你想做一些别的事

350
00:18:05,053 --> 00:18:09,088
比如，在这 如果ptr是一个有效的值

351
00:18:09,088 --> 00:18:11,097
如果它不为null 那就进行log函数

352
00:18:11,097 --> 00:18:15,012
但是如果我想 运行一些不是这个情况下发生的代码

353
00:18:15,012 --> 00:18:17,068
那我们就在后面加上else语句 所以我可以写

354
00:18:17,068 --> 00:18:21,085
（写代码）

355
00:18:21,085 --> 00:18:25,075
然后如果我运行我的程序你可以看到会发生的事

356
00:18:25,075 --> 00:18:28,000
他将要输出pointer is null

357
00:18:28,000 --> 00:18:31,010
当然因为我用debugger逐行调试代码

358
00:18:31,010 --> 00:18:33,095
这个pointer是null或者0

359
00:18:33,095 --> 00:18:35,035
这就会运行下面这个

360
00:18:35,035 --> 00:18:36,095
之后就会跳转到else后面的语句

361
00:18:36,095 --> 00:18:38,000
帅

362
00:18:38,000 --> 00:18:42,025
同样的 我们可以使用else if语句来继续添加条件分支

363
00:18:42,025 --> 00:18:46,032
也就是说 我可以检查这个ptr==“Hello”是否为真

364
00:18:46,032 --> 00:18:50,011
然后再键入代码log("pointer is hello");

365
00:18:50,011 --> 00:18:51,010
将会发生什么呢

366
00:18:51,010 --> 00:18:57,015
因为这是一个else if，只有当前面这个if后的条件为假了才会来检测else if 后的条件


367
00:18:57,015 --> 00:19:04,035
所以从理论上来说 我写在这里的代码可能从来不会运行 至少这个部分永远不会运行

368
00:19:04,035 --> 00:19:08,078
因为指针不是null 所以磁盘就不会去读取它

369
00:19:08,078 --> 00:19:13,080
如果我把我的指针设成….比如hello

370
00:19:13,080 --> 00:19:17,085
然后我按F5 接下来会发生什么

371
00:19:17,085 --> 00:19:22,056
就是这个指针不是null 所以这个分支就会执行

372
00:19:22,056 --> 00:19:25,088
如果我按F10 我们直接跳到最后

373
00:19:25,088 --> 00:19:27,053
因为这些代码根本不起作用

374
00:19:27,053 --> 00:19:32,085
只有当if后的条件为假时才会来检测else if后的条件

375
00:19:32,085 --> 00:19:35,007
然而如果我这么写

376
00:19:35,007 --> 00:19:37,050
把这个else if前的else去掉

377
00:19:37,050 --> 00:19:40,070
你会发现这个条件就会被检测

378
00:19:40,070 --> 00:19:44,003
然后检测成功 我们的控制台会有两个东西打印出来

379
00:19:44,003 --> 00:19:49,003
其实else if语句就是一个你可能不会注意到的小把戏

380
00:19:49,003 --> 00:19:51,050
但它就是发生了

381
00:19:51,050 --> 00:19:54,078
它也不过就是某种聪明地隐藏了语法的的方式

382
00:19:54,078 --> 00:20:00,025
我们再看看代码 我把它们写回原型

383
00:20:00,025 --> 00:20:03,032
写成两个独立的句型 

384
00:20:03,032 --> 00:20:05,068
看看这个新代码

385
00:20:05,068 --> 00:20:10,005
运行的结果和之前的一模一样

386
00:20:10,005 --> 00:20:16,047
所以说没有else if这样的整体 他们只是被结合到了一起

387
00:20:16,047 --> 00:20:22,078
就像我们把if(…)和log(…)写到了同一行一样

388
00:20:22,078 --> 00:20:27,022
就是个else 和 if

389
00:20:27,040 --> 00:20:30,078
我们前面在讲的 这个条件失效了

390
00:20:30,078 --> 00:20:34,015
才来验证下面这个ptr="hello"的条件

391
00:20:34,015 --> 00:20:37,070
就是说 只有在前面的if失败的情况下才会来执行else后的代码

392
00:20:37,070 --> 00:20:40,085
如果这是假 这段代码就会运行

393
00:20:40,085 --> 00:20:43,065
所以,不过是一些小把戏

394
00:20:43,065 --> 00:20:46,095
我记得我第一次发现这事的时候 觉得有些不可思议

395
00:20:46,095 --> 00:20:51,056
因为我没有意识到 我当时觉得else if像是某种关键字

396
00:20:51,056 --> 00:20:52,038
遗憾的是它不是

397
00:20:52,038 --> 00:20:56,022
在C++的定义中也根本没有else if这样的关键字

398
00:20:56,022 --> 00:20:57,095
就仅仅是else和if而已

399
00:20:57,095 --> 00:21:01,072
我们在做的就是把他们连在一起

400
00:21:01,072 --> 00:21:09,070
无论如何 我已经讲了很多关于if语句、条件和分支的基础知识

401
00:21:09,070 --> 00:21:12,060
希望各位能够理解这些东西是怎么工作的

402
00:21:12,060 --> 00:21:14,060
如果你感觉没全懂

403
00:21:14,060 --> 00:21:17,068
没什么关系 因为我讲得相当复杂

404
00:21:17,068 --> 00:21:23,040
从另一方面说就是我得有一点超纲

405
00:21:23,040 --> 00:21:27,025
我们会在代码中经常用到if语句

406
00:21:27,025 --> 00:21:30,097
编程有两个重要的组成部分

407
00:21:30,097 --> 00:21:33,097
一部分是数学编程(mathematical programming)一部分是逻辑编程(logical programming)

408
00:21:33,097 --> 00:21:37,075
只是我想把它分成这两部分而已

409
00:21:37,075 --> 00:21:43,035
当然也有些编程你只要进行数学运算即可

410
00:21:43,035 --> 00:21:45,015
确实有挺多的

411
00:21:45,015 --> 00:21:50,015
很多高效、高速的程序本质上都是数学运算

412
00:21:50,015 --> 00:21:54,070
之中，前面提到的逻辑编程就比较少

413
00:21:54,070 --> 00:21:56,090
它们全都是与逻辑相关的

414
00:21:56,090 --> 00:21:59,050
如果某个条件符合了，就去做某件事

415
00:21:59,050 --> 00:22:07,078
这有些无聊 我不是说它没必要

416
00:22:07,078 --> 00:22:14,003
世界上也没有游戏和应用是没有使用if语句的

417
00:22:14,003 --> 00:22:19,003
我的意思是 之后我们会 学习怎么去写更好的代码

418
00:22:19,003 --> 00:22:23,072
你会看到许多你用if语句的地方我就不会去用

419
00:22:23,072 --> 00:22:32,003
我可能会用某些运算来代替比较和分支

420
00:22:32,003 --> 00:22:36,003
因为这么做的话确实会让你的代码变快许多

421
00:22:36,003 --> 00:22:39,012
如果是考虑到所谓的工作时用的代码，它可能也会更实用

422
00:22:39,012 --> 00:22:43,062
无论如何，我就是在闲谈

423
00:22:43,062 --> 00:22:46,007
今天就讲到这

