1
00:00:00,003 --> 00:00:02,004
嘿大家好我是Cherno

2
00:00:02,004 --> 00:00:08,045
欢迎来到我的新一期C++视频，所以今天我们要学习C++是如何工作的

3
00:00:08,048 --> 00:00:13,048
我们目前会尝试保持简单，但我们会学习如何从源文件

4
00:00:13,068 --> 00:00:16,080
也就是文本文件转化到

5
00:00:16,080 --> 00:00:18,087
能运行的可执行二进制文件或者说程序

6
00:00:18,087 --> 00:00:27,033
写一个简单的c++程序的基本工作流程是你有一些源文件，上面有你写的文本

7
00:00:27,042 --> 00:00:31,012
然后把它传入一个编译器，然后编译成某种二进制文件（binary）

8
00:00:31,033 --> 00:00:35,060
这个binary可以说某种库，或者是实际的可执行文件

9
00:00:35,065 --> 00:00:39,075
今天我们主要讲可执行程序或者说可执行binary

10
00:00:39,075 --> 00:00:42,003
所以让我们打开VS来观摩

11
00:00:42,020 --> 00:00:49,003
ok，这里是我们的hello world应用，上期学习怎么配置windows c++写的

12
00:00:49,020 --> 00:00:52,028
非常简单的程序，但有很多东西在发生着

13
00:00:52,045 --> 00:00:57,028
首先我们有这个#include <iostream>语句，这种叫preprocessor语句（预处理指令）

14
00:00:57,045 --> 00:01:00,067
任何以井号开头的都是预处理指令

15
00:01:00,088 --> 00:01:06,035
当编译器收到一个源文件时它做的第一件事就是预处理你所有的预处理指令（preprocessor statement）

16
00:01:06,047 --> 00:01:11,007
 这就是为啥它们被称为预处理指令，因为它们发生在真正的编译之前

17
00:01:11,022 --> 00:01:16,003
在此处，我们用的是include，include所做的就是找到一个文件

18
00:01:16,012 --> 00:01:18,087
在此处我们找的是一个叫iostream的文件

19
00:01:18,087 --> 00:01:23,001
该文件里的所有内容会被复制黏贴到目前这个文件里

20
00:01:23,001 --> 00:01:28,060
你include的这些文件一般被称为header file(头文件)，我们今后会详细讨论

21
00:01:28,070 --> 00:01:31,059
我们之所以include这个叫iostream的东西是因为

22
00:01:31,059 --> 00:01:34,047
我们需要一个函数(function)：cout的声明

23
00:01:34,056 --> 00:01:39,032
cout使我们能够打印东西到console（控制台），然后我们有这个main函数，main函数相当重要

24
00:01:39,033 --> 00:01:44,062
因为每个c++程序都有类似这个main函数的东西，它被称作入口点（entry point）

25
00:01:44,075 --> 00:01:52,018
也就是进入我们程序的入口，也就是说当我们要运行我们的程序时，计算机会从该函数里的代码开始执行

26
00:01:52,028 --> 00:01:56,045
程序运行时，我们电脑会一行一行按照顺序运行我们写的代码

27
00:01:56,055 --> 00:02:00,045
当然有一些东西可以打破或者改变执行的顺序

28
00:02:00,053 --> 00:02:04,030
那些很多时候是control flow statements（控制流语句）或者是调用其他函数

29
00:02:04,060 --> 00:02:08,055
但要点就是我们的程序是一行一行被执行的

30
00:02:08,055 --> 00:02:12,088
所以我们程序第一个被执行的就是这句hello world cout语句

31
00:02:12,089 --> 00:02:18,080
然后就是这句cin.get()函数，然后因为这就是我们main函数，的所有东西了

32
00:02:18,095 --> 00:02:20,099
所以我们的程序会终止

33
00:02:20,099 --> 00:02:25,068
对于函数熟悉的同学，你们可能会注意到main函数的返回类型(return type)其实是int（整型）,

34
00:02:25,070 --> 00:02:28,000
然而我们并没有返回一个整数(integer)

35
00:02:28,007 --> 00:02:33,073
这是因为main函数其实是个例外，你不需要从主函数返回任何类型的值

36
00:02:34,010 --> 00:02:39,077
如果你不返回任何值，它会返回0，这只适用于main函数,是个例外

37
00:02:39,093 --> 00:02:42,055
好了我们再讲一下，这句到底在干嘛

38
00:02:42,068 --> 00:02:48,060
这种语法对c++新手看起来可能会很奇怪，其实写成这样是很不幸的

39
00:02:48,062 --> 00:02:51,032
因为你第一次看它的时候确实看不出来意思

40
00:02:51,047 --> 00:02:57,093
这些向左的带角的括号，看起来有点像左位移符号(bit shift)，其实是被重载的符号

41
00:02:58,018 --> 00:03:06,030
你得把它们想象成一个函数，我知道它们看起来像运算符(operator)，但实际上呢，运算符就是函数

42
00:03:06,030 --> 00:03:11,030
所以在这种情况下就跟类似cout.print一模一样的

43
00:03:11,043 --> 00:03:20,048
然后hello world是我们的parameter（参数），然后我们可能再接着加一个print，不过如此

44
00:03:20,048 --> 00:03:25,082
你得把这些操作符想象成函数，如果你能这么想象会更好理解一点

45
00:03:25,090 --> 00:03:33,073
所以我们在这边做的就是我们把这个Hello world字符串传入这个cout，cout就是把它打印在控制台里

46
00:03:33,073 --> 00:03:38,095
然后我们又传入一个endl（end line),end line就是告诉我们的控制台前进到另一行

47
00:03:39,014 --> 00:03:44,080
cin.get()函数在我们这种情况下其实就是等待我们输入回车，然后才会接着执行底下一行代码

48
00:03:44,085 --> 00:03:51,060
我们底下一行当然什么也没有，我就是说我们的程序会在这一行暂停，直到我们按回车

49
00:03:51,060 --> 00:03:54,032
因为这个函数基本上就是会等待我们输入回车

50
00:03:54,032 --> 00:04:00,038
然后我们进入下一行，下一行什么也没有，也就是说会返回0，说明我们的程序成功运行了

51
00:04:00,055 --> 00:04:08,087
这就是我们的整个程序了。okay所以这是我们的源文件，我们其实有这样一个main.cpp文件也就是我们源文件

52
00:04:08,087 --> 00:04:13,050
我们怎么从这个文件到可执行程序呢

53
00:04:13,050 --> 00:04:16,002
基本上我们会经历几个阶段

54
00:04:16,012 --> 00:04:24,050
首先是这个include iostream，就是我们所说的preprocessor语句，会在编译文件之前被评估

55
00:04:24,080 --> 00:04:36,005
这句呢其实就是把iostream文件里，的所有内容拷贝到这个文件里，就是字面意思，拷贝和粘贴到这个文件里

56
00:04:36,005 --> 00:04:42,050
如我之前所说，之后我会更深入的讲，所以现在别太担心不懂它

57
00:04:42,062 --> 00:04:49,020
目前你需要知道的就是我们include这个文件，就是为了用cout和cin这两个函数

58
00:04:49,023 --> 00:05:01,017
当我们的preprocessor被评估以后，我们的文件会被编译。这个阶段，编译器把我们的c++代码转化成实际的机器码

59
00:05:01,036 --> 00:05:06,010
其实有几个很重要的设置来决定这一切是如何发生的，我们简单看一下它们

60
00:05:06,010 --> 00:05:14,060
在vs里，有这两个重要的下拉选项，一个叫solution configuration（方案配置？），一个叫solution platform（方案平台） 

61
00:05:14,062 --> 00:05:19,083
默认会被设为debug，然后要么是x86 或者win32，它俩一回事

62
00:05:19,083 --> 00:05:26,000
如果我们点开debug，你会看到有两个选项，debug和release，这两个选项在vs里是新建项目时的默认设置

63
00:05:26,008 --> 00:05:28,000
然后在方案平台里有x6 
4 和x8
6两个选项,它们依然只是默认选项

64
00:05:32,079 --> 00:05:37,092
配置(configuration)只是一系列规则用于如何build一个项目

65
00:05:38,000 --> 00:05:44,012
而solution platform呢，是我们的目前编译的目标平台

66
00:05:44,012 --> 00:05:51,095
举个例子x86就是定位于32位windows，也就是说我们会生成一个用于windows的32位的程序

67
00:05:52,006 --> 00:05:53,035
更复杂的项目可能会面向不同的平台

68
00:05:54,070 --> 00:06:04,033
你可能会有一个安卓平台，然后如果你想build、部署、以及debug安卓程序，你就得把平台改成安卓

69
00:06:04,048 --> 00:06:09,042
至于solution configuration，是定义如何为这个平台编译的一系列规则

70
00:06:09,057 --> 00:06:12,090
我们来看一下有哪些规则可以改

71
00:06:12,097 --> 00:06:15,019
在项目上右击，选properties（属性）

72
00:06:15,019 --> 00:06:21,092
这就是vs的properties页面，这些就是定义在哪些配置和平台去如何build的一些规则

73
00:06:21,092 --> 00:06:34,055
首先你要注意的是这个configuration和platform两个区域，确保你的configuration和platform有被设置为你确实想要修改的那个选项

74
00:06:34,055 --> 00:06:39,025
有时候鬼知道什么原因会被设置到release选项，而你显然在build一个debug的

75
00:06:39,034 --> 00:06:42,045
那么这边所有的改变都不会被应用到你目前的配置

76
00:06:42,045 --> 00:06:47,027
如果你忘了这一点，你可能会疑惑为啥不管用，我就砰到好几次了,是挺烦的

77
00:06:47,035 --> 00:06:56,062
我们在这个debug配置了，你看我们这里有win32，win32就是x86，一模一样的，不知为啥有不同名字

78
00:06:56,062 --> 00:07:02,050
这里有一些sdk的基本信息，版本啊，输出目录，中继目录和一些其他东西

79
00:07:02,070 --> 00:07:06,092
需要注意的是，我们项目的Configuration type是设置为Application的

80
00:07:06,093 --> 00:07:10,040
如果我们想要一个库，可以在这里更改

81
00:07:10,040 --> 00:07:13,023
但这就是编译会产出的二进制文件了

82
00:07:13,030 --> 00:07:16,070
由于我们本来就要一个可执行程序，就选application.exe了

83
00:07:16,073 --> 00:07:20,062
编译器设置位于这个C/C ++这里

84
00:07:20,075 --> 00:07:23,000
这里有一些重要设定，比如additional include directories、

85
00:07:23,012 --> 00:07:33,050
可能需要用到的优化设置、代码生成设置、预处理定义，以及一大堆我们近期都不会触及的东西

86
00:07:33,057 --> 00:07:37,083
vs的默认设置其实蛮不错的，所以我们其实不用做什么

87
00:07:37,089 --> 00:07:41,077
但这些就是决定我们的文件被如何编译的规则了

88
00:07:41,094 --> 00:07:45,062
你可以很明显地看到debug和release配置的区别

89
00:07:45,077 --> 00:07:52,002
如果你进入optimization（优化）标签，把configuration改成release，就可以看到optimization被设置成maximize speed（速度最大化）

90
00:07:52,017 --> 00:07:59,075
而在debug下是disabled（禁用）状态，这就是debug模式默认会比release慢许多的原因之一

91
00:07:59,088 --> 00:08:06,012
因为优化被关了，当然关闭优化会有助于我们debug，之后我们就会发现了

92
00:08:06,030 --> 00:08:14,085
如果你想知道编译器怎么工作的，我专门做了一期视频深入解释，如果你感兴趣，请去查看

93
00:08:14,085 --> 00:08:16,027
链接在youtube视频的描述里

94
00:08:16,040 --> 00:08:23,005
所有.cpp文件都会被编译，而头文件(header file)则不会，只有cpp

95
00:08:23,019 --> 00:08:31,048
记住header file通过preprocessor被include到cpp文件里，那是它们被编译的时候

96
00:08:31,052 --> 00:08:36,030
所以我们有一堆cpp文件被编译，而且它们是一个个单独被编译的

97
00:08:36,054 --> 00:08:44,017
每个cpp文件会被编译成一个object文件，扩展名的话，用windows编译器是.obj

98
00:08:44,028 --> 00:08:53,083
当我们有了一个个obj文件，也就是cpp文件被编译过后的结果，我们得有办法把它们联系起来，组成一个exe

99
00:08:53,097 --> 00:08:56,003
这时就是我们的朋友linker（链接器）的用武之处了

100
00:08:56,015 --> 00:09:04,042
你可以在linker标签下看到linker的设定，但基本上linker就是把所有obj拿过来，然后把它们联系起来

101
00:09:04,050 --> 00:09:17,017
所以linker的作用就是把所有obj缝起来组成一个exe，当然它究竟怎么做到的其实很复杂，所以我也做了一个视频讲它

102
00:09:17,041 --> 00:09:20,017
记得去看哟，链接在描述里

103
00:09:20,017 --> 00:09:22,030
我们来实际看看它运行

104
00:09:22,030 --> 00:09:30,062
首先我打算只编译这个cpp文件，在vs里，你可以按ctrl + F7 单独编译文件

105
00:09:30,070 --> 00:09:35,072
在output窗口可以看到我们在building这个main.cpp文件，而且成功了

106
00:09:35,097 --> 00:09:39,022
如果不想按ctrl+F7的话，可以调出这个compile按钮

107
00:09:39,022 --> 00:09:50,015
可以右击这里，然后点击build，然后点add/remove buttons->customize->add command，选build，找到compile

108
00:09:50,025 --> 00:09:53,070
所以点击这个按钮以后，我们的文件就在编译了

109
00:09:53,070 --> 00:10:00,053
如果我们有什么语法错误，比如说少了个分号，就可以看到提示error

110
00:10:00,053 --> 00:10:08,066
vs会有很多方式呈现错误，其中一种是这个error list，另一种是在output窗口

111
00:10:08,083 --> 00:10:13,072
我现在就可以告诉你，这个error list基本上就是垃圾

112
00:10:14,032 --> 00:10:21,047
它可能会显得易读，特别是像这种错误，但你千万别指望它，很多时候它都缺失了很多信息

113
00:10:21,047 --> 00:10:32,080
error list的工作原理其实是，解析(parse)output窗口，找error关键字，然后从那找信息，放入这个list

114
00:10:32,090 --> 00:10:36,057
是一个不错的概述，你只能把它当概述看

115
00:10:36,065 --> 00:10:42,072
但如果你要根具体的、所有的错误信息，你只能通过output窗口

116
00:10:42,072 --> 00:10:48,050
所以本系列接下来我都只会通过output看error信息，请务必习惯

117
00:10:48,057 --> 00:10:54,067
可以看到这里说有个语法错误，大括号前缺少一个 “;”

118
00:10:54,080 --> 00:11:02,003
它会告诉你error发生在哪一行，如果你双击它，会带你到源码中到错误处 

119
00:11:02,014 --> 00:11:11,022
所以让我们来加个分号修理好它，再次按ctrl+F7来build这个文件，然后我们就获得了编译好的文件

120
00:11:11,022 --> 00:11:16,097
当你单独编译一个文件，linking（链接）显然不会发生，因为你是编译单独一个文件

121
00:11:17,003 --> 00:11:21,039
所以linker完全没工作，我们去看看编译器到底生成了啥

122
00:11:21,039 --> 00:11:28,005
如果你右击我们的项目，这里有个Open file in File Explorer选项，这个会打开文件管理器

123
00:11:28,020 --> 00:11:36,003
默认vs会build到这个Debug文件夹，进去可以看到有个main.obj文件

124
00:11:36,030 --> 00:11:43,062
这是编译器生成的obj文件，再说一遍，项目里每个文件都会产生这么一个obj

125
00:11:43,088 --> 00:11:51,087
如果我们回到vs，build整个项目，也就是不止编译一个文件,而是整个项目

126
00:11:51,087 --> 00:11:55,042
可以看到我们拿到了这个exe

127
00:11:55,050 --> 00:12:01,047
如果我们回到文件管理器，它会在solution目录下，debug文件夹

128
00:12:01,068 --> 00:12:07,080
是的，vs默认地址有点诡异，我一般喜欢改掉，但现在我不打算搞的很复杂

129
00:12:07,080 --> 00:12:13,017
然后就是可以运行的hello world.exe，然后打印出hello world

130
00:12:13,038 --> 00:12:18,033
这是个简单的概观，但如果我们有多个c++文件呢

131
00:12:18,042 --> 00:12:23,040
我们来看个简单的例子，假设我们有打印hello world到控制台

132
00:12:23,053 --> 00:12:27,057
但我不想用这个cout，而想用我自己的logging函数

133
00:12:27,075 --> 00:12:30,015
那个可能会包装这个cout

134
00:12:30,030 --> 00:12:41,075
我们来写个Log函数，会接受一个cstring作为参数,取名为message,并打印该message到控制台

135
00:12:41,097 --> 00:12:49,083
非常简单，如果你现在还不懂什么是const char*，别担心，我们会在今后的视频讲string

136
00:12:50,000 --> 00:12:55,050
暂时你只要知道，const char* 就是存储一个一串字符

137
00:12:55,062 --> 00:12:59,088
所以现在我们可以把我们代码改成用log而非cout，然后打印hello world

138
00:13:00,000 --> 00:13:10,003
call log，传入参数hello world，然后点local windows debugger，确认还可以工作

139
00:13:10,017 --> 00:13:15,008
可以看到成功了，很好，我们写了第一个函数，挺简单的

140
00:13:15,028 --> 00:13:22,020
现在我们把它放入另一个文件，因为我不想main.cpp充斥着许多代码

141
00:13:22,078 --> 00:13:26,062
我想分成多个文件，保持清爽有条理

142
00:13:27,003 --> 00:13:32,017
我们在source files下新建一个文件，右键，add new item

143
00:13:32,035 --> 00:13:37,025
建个cpp，管它叫log.cpp，点add

144
00:13:37,042 --> 00:13:46,028
然后我打算回到main，剪切这个log函数，粘贴到这

145
00:13:46,048 --> 00:13:51,020
现在log.cpp里有个叫log到函数了。我们试着编译下单独这个文件

146
00:13:51,037 --> 00:13:56,065
嘿，看碰到许多errors，如果你看output窗口，你会发现说cout不是STD的member(成员)

147
00:13:56,065 --> 00:14:04,060
这基本上在说它不懂cout到底是啥，原因是我们没有把cout的声明include进来

148
00:14:04,067 --> 00:14:09,015
c++里每个symbol(符号?标记？不知道怎么翻译)都需要某种形式的声明

149
00:14:09,028 --> 00:14:16,047
cout是在main里include的文件里定义的一个函数，那个文件也就是iostream

150
00:14:16,075 --> 00:14:21,085
让我们把iostream剪切到这个文件上方，从而include iostream

151
00:14:21,094 --> 00:14:25,055
这样做，我们就include了cout的声明

152
00:14:25,065 --> 00:14:29,072
我们再次编译该文件，可以到成功了，很好

153
00:14:29,097 --> 00:14:35,017
回到main，我想调用这个log函数，我们可以吗？按ctrl+F7，不行

154
00:14:35,017 --> 00:14:45,088
因为log找不到，我们也收到一个关于cin的抱怨，我们已经知道这是因为没有include iostream，所以它不知道是啥

155
00:14:46,012 --> 00:14:50,038
我们可以恢复这个include，我们的问题就解决了

156
00:14:50,050 --> 00:14:59,042
然后log还是找不到，为啥呢，我们把一个函数从一个文件移动到了另一个

157
00:14:59,078 --> 00:15:08,023
我们是分别编译它们的，所以main.cpp不知道有个叫log的函数在哪

158
00:15:08,023 --> 00:15:15,097
由于它识别不出，所以向我们报告编译错误，我们可以通过提供一个声明(declaration)来解决

159
00:15:16,008 --> 00:15:22,057
一个声明，就是字面意思，声明一个叫log的东西是存在的

160
00:15:22,062 --> 00:15:31,015
这其实有点像承诺，因为我们可以告诉编译器有个函数叫log，而编译器就真的会相信

161
00:15:31,039 --> 00:15:35,097
这就是编译器的美好之处，编译器会说，是吗，好的，我完全信任你

162
00:15:35,097 --> 00:15:41,000
因为编译器根本不关心resolving（解析）log到底在哪被定义的

163
00:15:41,014 --> 00:15:44,060
所以这里有两个词汇，declaration（声明）和definition（定义）

164
00:15:44,080 --> 00:15:50,033
声明就是说这个symbol这个函数存在

165
00:15:50,050 --> 00:15:57,050
定义则是说这个函数到底是什么，这是这个函数主体

166
00:15:57,050 --> 00:16:00,088
那我们来写个log的声明

167
00:16:00,088 --> 00:16:16,040
声明看起来很像实际的定义，这个就是定义，我们不仅声明了名字log，而且有主体(body),里面含有代码 

168
00:16:16,051 --> 00:16:25,010
回到main，声明很像定义，但缺的是body

169
00:16:25,020 --> 00:16:29,095
你看我只需要在最后打一个分号就完事了

170
00:16:29,095 --> 00:16:35,042
实际上，你都不需要提供参数的名字，因为不需要，这就可以了

171
00:16:35,072 --> 00:16:39,072
但根据经验法则，我还是喜欢给个名字，因为更好理解

172
00:16:39,085 --> 00:16:44,056
我们来编译一下，看，编译器完全信了我们的鬼话

173
00:16:44,056 --> 00:16:55,015
在这个时候，你可能会问，编译器怎么知道我有个log在别的文件里呢，如果我们只是编译这一个文件

174
00:16:55,025 --> 00:17:04,055
回答是它不知道，它信我们，那你的下一个问题就会是它怎么知道运行正确的代码

175
00:17:04,065 --> 00:17:07,012
这就是linker出场的时候了

176
00:17:07,012 --> 00:17:12,060
当我们build整个项目而非单独文件时，如果我右键然后选build

177
00:17:12,075 --> 00:17:21,018
当我们的文件被编译后，linker会去找log的定义，然后跟我们main里调用的联系起来

178
00:17:21,018 --> 00:17:25,070
如果它找不到定义，我们会得到一个linker error

179
00:17:25,082 --> 00:17:33,018
很多人很怕linking error，我们来看看例子

180
00:17:33,045 --> 00:17:39,097
如果我现在run，你可以看到还是可以打印hello world，一切ok

181
00:17:40,018 --> 00:17:46,097
然而，让我们拿掉这个，或者至少改下这个，改成logr，保存

182
00:17:47,010 --> 00:17:50,090
回到main，我会试着单独编译这个文件

183
00:17:51,005 --> 00:17:56,035
可以看到没有任何问题，但右击hello world然后build，

184
00:17:56,035 --> 00:18:03,012
看啊，我们拿到了这个吓人的error信息，在output里看起来很可怕

185
00:18:03,025 --> 00:18:08,068
之所以看起来吓人是因为有一些额外的信息，关于函数签名（signature）的

186
00:18:08,082 --> 00:18:12,080
比如这里，有calling convention以及实际的ID

187
00:18:12,080 --> 00:18:17,093
但它基本上在告诉你，你有一个没有被解析的外部标记(external symbol)叫log

188
00:18:18,020 --> 00:18:24,025
它有这样一个返回类型和这些参数，然后你在main里引用(referencing)它

189
00:18:24,040 --> 00:18:28,090
一个unresolved external symbol意思是linker无法解析一个symbol

190
00:18:29,010 --> 00:18:33,053
记住，linker的工作就是resolve symbols，联通各个函数

191
00:18:33,056 --> 00:18:41,040
而它无法找到log应该跟谁联系起来，因为我们没有log这个函数被定义

192
00:18:41,066 --> 00:18:51,082
我们可以通过更正函数名来解决，我们需要提供log的定义，也就是说提供一个body

193
00:18:52,000 --> 00:18:56,045
没说一定要在这个文件里，也可以在main里，但必须存在于某处

194
00:18:56,053 --> 00:18:59,027
编译它，没有任何错误了

195
00:18:59,027 --> 00:19:04,040
如果我们回到文件管理器，看看在我们的中继(intermediate)目录下有啥

196
00:19:04,040 --> 00:19:11,038
可以看到我们有两个obj，因为编译会为每个cpp生产一个obj

197
00:19:11,040 --> 00:19:14,080
然后linker会拿到它们，串成一个exe

198
00:19:14,093 --> 00:19:24,018
所以在我们这个例子里，我们的log定义在这个log.obj里，main函数在main.obj

199
00:19:24,032 --> 00:19:34,025
然后linker会把log的定义拿到一个公共的binary里，也就是hello world.exe

200
00:19:34,055 --> 00:19:37,080
它包含log和main的定义

201
00:19:37,080 --> 00:19:41,018
这就是一个c++如何工作的概览了

202
00:19:41,050 --> 00:19:46,003
再次强烈推荐大家去看深入解读编译和链接的视频

203
00:19:46,031 --> 00:19:56,020
因为它们相比本视频有更多信息，本视频只是大概讲一下从源文件到binary的管线

204
00:19:56,078 --> 00:20:13,085
（别忘记关注我blablabla后面不翻译了）

