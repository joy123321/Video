1
00:00:00,000 --> 00:00:04,008
嘿，大家好！我是Cherno。欢迎回到我的C++系列。

2
00:00:04,008 --> 00:00:09,006
今天，我们将采用到目前为止我们从类中学到的知识，并且必须从头开始编写类。

3
00:00:09,007 --> 00:00:13,005
我今天不打算走得太远，我们不会写一些非常复杂的类。

4
00:00:13,005 --> 00:00:18,002
我们只是要编写一个基本的 Log 类，它应该演示我们迄今为止学到的一些基本功能。

5
00:00:18,002 --> 00:00:22,009
在接下来的几集中，我们将继续研究这门课，并慢慢引入新的概念。

6
00:00:22,009 --> 00:00:28,004
因此，您将看到从类的基本版本到更高级版本的过程和差异。

7
00:00:28,004 --> 00:00:31,005
它做同样的事情，但可以被认为是更好的代码。

8
00:00:31,005 --> 00:00:36,005
但首先，此视频是由Amazon Music Unlimited带给您的，这是一个很棒的无广告流媒体

9
00:00:36,005 --> 00:00:40,009
和下载服务，超过四千万首歌曲，您可以随时随地收听。

10
00:00:40,009 --> 00:00:44,009
用这种音乐编程是不一样的。我的意思是，每天在工作中，

11
00:00:44,009 --> 00:00:48,007
我已经戴上了耳机。我在听音乐。我正在集中精力，我正在写一个好的代码。

12
00:00:48,007 --> 00:00:53,009
在下面的描述中，我有一个指向Amazon Music Unlimited的30天免费试用版的链接。所以，请继续尝试一下。

13
00:00:54,000 --> 00:00:58,001
如果您确实注册了，它确实有助于支持频道和本系列。因此，非常感谢那些这样做的人。

14
00:00:58,001 --> 00:01:00,003
好吧，让我们来谈谈我们将要编写的日志类。

15
00:01:00,003 --> 00:01:05,001
什么是日志类？因此，此 Log 类将成为我们管理日志消息的一种方式。

16
00:01:05,002 --> 00:01:09,006
因此，换句话说，我们希望程序将消息或信息打印到控制台。

17
00:01:09,007 --> 00:01:14,003
这通常用于调试目的，它可以在我们的游戏或应用程序中真正帮助我们，

18
00:01:14,003 --> 00:01:18,008
如果我们想看看发生了什么，只需将事物的状态打印到我们的控制台中即可。

19
00:01:18,009 --> 00:01:26,000
因为我们应用程序中的控制台实际上就像一个信息转储，我们可以用它来打印出正在发生的事情。

20
00:01:26,001 --> 00:01:29,006
它实际上也是可以保证始终有效的东西，对吧？

21
00:01:29,007 --> 00:01:36,001
如果我们在游戏中有一个控制台的图形显示，或者可能有一些不同的东西，它可能不会一直工作。

22
00:01:36,002 --> 00:01:41,007
因为如果我们的图形渲染系统或类似的东西有东西，我们可能无法正确打印这些消息。

23
00:01:41,008 --> 00:01:45,006
但是，控制台基本上是内置于操作系统中的东西。

24
00:01:45,007 --> 00:01:49,000
因此，我们几乎可以保证它始终有效。

25
00:01:49,001 --> 00:01:57,008
我也非常喜欢使用 Log 类作为示例的想法，因为日志记录系统可以像您希望的那样简单或复杂。

26
00:01:57,008 --> 00:02:04,008
令人惊讶的是，一些日志系统是多么复杂。我说的是数千行代码，只是为了打印到控制台。

27
00:02:04,008 --> 00:02:10,006
但它对于调试和开发非常重要，绝对值得花时间。

28
00:02:10,007 --> 00:02:13,003
不仅如此，日志记录系统还可以执行以下操作：

29
00:02:13,003 --> 00:02:20,001
只打印到控制台，打印不同颜色的控制台，实际上将日志消息输出到文件或网络......

30
00:02:20,001 --> 00:02:26,005
你可以做的太多了，你可以从字面上使日志类成为十行代码或一万行代码。

31
00:02:26,008 --> 00:02:31,003
就是这样，这就是为什么它是一个很好的例子。

32
00:02:31,003 --> 00:02:33,009
好吧，我们的课程一开始会相当简单。

33
00:02:33,009 --> 00:02:37,002
它基本上将提供向控制台写入文本的功能。

34
00:02:37,003 --> 00:02:43,009
它将维护某种日志级别，这基本上是我们实际要发送到控制台的日志消息级别。

35
00:02:44,000 --> 00:02:49,004
因此，我们将从三个级别开始。我们将有错误、警告和消息或跟踪。

36
00:02:49,005 --> 00:02:53,001
所以基本上，我们能做的是，我们可以把我们本地系统的级别设置为这样说：

37
00:02:53,001 --> 00:02:57,008
例如，警告，这意味着将仅打印警告和错误，但不会跟踪消息。

38
00:02:58,000 --> 00:03:03,009
所以，如果你不想看到一堆信息，你只是想看看出了什么问题或你的警告是什么，这真的很有用。

39
00:03:04,001 --> 00:03:08,005
您可以通过过滤实际发送和打印的内容来清理控制台。

40
00:03:08,007 --> 00:03:10,009
好吧，让我们跳进去看看它可能是什么样子。

41
00:03:10,009 --> 00:03:15,000
好的，所以第一步当然是创建该日志类。我只是要编写类日志。

42
00:03:15,000 --> 00:03:16,004
好吧，我们下去了（我现在可以去吗？

43
00:03:16,004 --> 00:03:23,007
所以现在我想让你想想Log类将如何实际工作，创建新类或设计API的一个非常好的方法是使用它。

44
00:03:23,008 --> 00:03:29,002
所以，我实际上将进入这个main函数，并开始输入如何使用该Log类。

45
00:03:29,002 --> 00:03:31,007
所以，首先，当然，我要实例化它。

46
00:03:31,007 --> 00:03:38,001
我可能想指定某种 loglevel 作为实际参数，但现在我将跳过它。

47
00:03:38,001 --> 00:03:45,009
我肯定会想要设置一个日志级别，所以我可能会做一些类似设置级别的事情，然后可能像LogLevelWarning这样的警告。

48
00:03:45,009 --> 00:03:52,004
因此，这意味着实际上只会打印警告或更重要的消息，或者警告或错误，而不会打印跟踪消息。

49
00:03:52,005 --> 00:03:58,001
然后我可能想要记录一个警告，所以我可能会做一些类似日志的事情。Warn（“Hello”）或类似的东西。

50
00:03:58,001 --> 00:04:03,001
所以现在我知道我的日志类应该是什么样子了。我现在就可以回去开始填写空白。

51
00:04:03,002 --> 00:04:08,009
所以在这里，我将从我制作的所有公共函数开始，这将是一个SetLevel函数。

52
00:04:09,001 --> 00:04:12,007
现在，我们只是使用整数作为对数级别来保持简单。

53
00:04:12,007 --> 00:04:15,009
这肯定会做一些事情，然后我也有Warn（），

54
00:04:15,009 --> 00:04:21,008
所以 Warn（） 将接收一个 const char 指针，这将是我们的消息。

55
00:04:21,009 --> 00:04:27,006
我们只是要使用const char指针，现在有字符串。我实际上要制作一集关于C++弦的剧集。

56
00:04:27,006 --> 00:04:31,007
某种我现在不会把事情复杂化太多，所以我们只是使用const char指针。

57
00:04:31,007 --> 00:04:35,001
为了我们的目的，这样做真的没有坏处，我们去了。

58
00:04:35,001 --> 00:04:38,006
所以现在我们不再得到任何错误，因为这些函数确实存在。

59
00:04:38,006 --> 00:04:42,006
但是，当然，LogLevelWarning没有。因此，让我们从声明日志级别开始。

60
00:04:42,007 --> 00:04:48,009
我们将需要某种私有成员变量，它将维护日志实际设置为的级别。

61
00:04:48,009 --> 00:04:51,009
它将是一个整数，我将称之为LogLevel。

62
00:04:52,000 --> 00:04:59,000
现在知道我在这个调用约定上使用了这个m，它基本上告诉我这是一个私有的类成员变量。

63
00:04:59,001 --> 00:05:04,001
这样，当我在函数中编写代码时，我最终引用了诸如此类的成员变量。

64
00:05:04,002 --> 00:05:10,003
我知道哪些实际上是类作用域的一部分，哪些是成员变量，哪些只是局部变量。

65
00:05:10,003 --> 00:05:16,005
当然，使用这样的约定不是必需的，但它确实有助于您实际组织代码并保持其干净，

66
00:05:16,006 --> 00:05:20,007
特别是当你处理大型代码库和复杂的类之类的东西时。

67
00:05:21,000 --> 00:05:25,000
它有很大的帮助，所以我真的建议你遵循这样的惯例。

68
00:05:25,000 --> 00:05:30,006
这就是我们编写的 SetLevel 函数，您可以看到它所做的只是用参数分配我们的成员变量。

69
00:05:30,006 --> 00:05:36,000
因此，如果我用两个调用 SetLevel，它将在此处将值 2 分配给我们的成员变量。

70
00:05:36,001 --> 00:05:39,009
让我们把它带回LogLevelWarning，让我们真正开始创建这些整数。

71
00:05:40,000 --> 00:05:44,004
所以，这不仅仅是说两个是信息或痕迹，而我那个将是零与错误。

72
00:05:44,004 --> 00:05:48,004
当然，如果我只是编写像 SetLevel（1） 这样的代码，这会使代码有点难以阅读。

73
00:05:48,004 --> 00:05:54,006
那么，什么是第一级？这就像我不知道我必须基本上记住这一点，一个是警告，我们不想处理这个问题。

74
00:05:54,006 --> 00:06:00,001
如果其他人提出代码，他们会发现有点困难，就像什么是代码一样？这是什么意思？

75
00:06:00,002 --> 00:06:05,001
因此，我们想要创建某种变量，该变量的值为一，表示我们实际想要表示的内容。

76
00:06:05,001 --> 00:06:12,002
在这种情况下，这是LogLevelWarning。所以，我要来到这里，我实际上要把它们变成公共变量。

77
00:06:12,002 --> 00:06:18,006
现在你可以看到我在这里公开写了两次，那是因为我喜欢把班级的不同部分分开。

78
00:06:18,006 --> 00:06:21,008
因此，换句话说，公共方法可能位于一个部分中，

79
00:06:21,008 --> 00:06:27,002
然后公共变量可能会进入另一个部分，也许公共静态变量可能会再次进入另一个部分。

80
00:06:27,002 --> 00:06:31,000
这只是我风格的一部分。你不必遵循它，但这是一个建议。

81
00:06:31,001 --> 00:06:36,008
这些将是常量，所以我将编写const int，然后编写LogLevelWarning，它将设置为1。

82
00:06:36,009 --> 00:06:40,007
我还将为错误编写一个日志级别，该级别将设置为零。

83
00:06:40,008 --> 00:06:46,005
然后，我将再为日志级别跟踪编写一个，我可能会将其称为LogLevelInfo。我将它设置为等于 2。

84
00:06:46,005 --> 00:06:51,005
因此，我们有三种类型的日志消息。我们有错误，我们有警告，我们只有信息消息。

85
00:06:51,006 --> 00:06:57,000
默认情况下，我将把我的 LogLevel 指定为 LogLevelInfo，这意味着所有内容都应该被打印出来。

86
00:06:57,001 --> 00:07:03,000
现在终于，我可以编写我的Warn函数了，所以我肯定希望我的Warn函数从控制台中打印出一些东西，

87
00:07:03,000 --> 00:07:07,001
所以，我将从现在开始使用cout，然后只是记录我的消息。

88
00:07:07,002 --> 00:07:11,002
但是，我可能想做的一件事是实际打印它是哪种消息。

89
00:07:11,003 --> 00:07:16,003
所以，换句话说，如果这是一个警告，我可能想在前面打印警告，然后我的消息，

90
00:07:16,004 --> 00:07:20,002
如果是信息，我会在前面打印信息，然后在我的消息等。

91
00:07:20,002 --> 00:07:24,007
所以，我绝对想打印类似的东西，也许，“[警告]：”，然后是我的消息。

92
00:07:24,008 --> 00:07:29,008
好吧，我们走了，这看起来很不错。因此，让我们复制并粘贴此函数，并为错误创建一个版本。

93
00:07:29,008 --> 00:07:36,004
在 Info 的另一个版本中，我将调用此信息。我要把它改成信息，

94
00:07:36,005 --> 00:07:41,005
我将把这个改成错误。当然，这将是我的错误函数。

95
00:07:41,005 --> 00:07:45,006
好吧，很酷。所以我们有一种方法可以设置日志级别，我们有错误，警告和信息。

96
00:07:45,006 --> 00:07:50,004
但是，当然，现在所有这些消息都将一直被打印出来，因为我们没有办法说

97
00:07:50,005 --> 00:07:54,004
“嘿，如果 LogLevel 设置为警告，请不要打印信息消息。

98
00:07:54,004 --> 00:07:58,004
我们可以通过以下方式添加它...我们可以添加该功能非常简单的if语句。

99
00:07:58,004 --> 00:08:06,004
换句话说，如果日志级别，则当前 LogLevel 实际上大于或等于此特定消息的级别，

100
00:08:06,006 --> 00:08:08,006
然后继续。这很好。

101
00:08:08,007 --> 00:08:12,003
因此，我们知道在这种情况下，LogLevelError 设置为等于零，

102
00:08:12,003 --> 00:08:20,001
这意味着，如果 LogLevel 为零或更高，它将记录此消息。我们将相同的代码复制并粘贴到“警告”和“信息”中。

103
00:08:20,002 --> 00:08:25,004
当然，将此更改为 LogLevelWarning，将此更改为 LogLevelInfo。

104
00:08:25,004 --> 00:08:31,009
那么为什么会出现这种情况，当然，如果我们将级别指定为LogLevelWarning，这意味着我们将LogLevel设置为一个。

105
00:08:32,000 --> 00:08:38,004
如果我们尝试记录一个信息，那么这个比较将是一大于或等于二。

106
00:08:38,005 --> 00:08:44,006
但是，当然，1 不大于或等于 2，因此不会打印此消息，因为此 if 语句的计算结果为 false。

107
00:08:44,007 --> 00:08:51,001
我们在这里有最后一个错误，因为LogLevelWarning当然是未定义的，因为LogLevelWarning位于我们的Log类中。

108
00:08:51,002 --> 00:08:57,003
因此，为了解决这个问题，我们只需将其设置为日志即可。LogLevelWarning，我们开始了。我们已将级别设置为警告。

109
00:08:57,004 --> 00:09:01,000
让我们继续通过按Ctrl + F7编译此代码，确保一切正常。

110
00:09:01,000 --> 00:09:03,007
我将按 F5 运行我的代码。

111
00:09:03,008 --> 00:09:08,006
好吧，看看这个。我们有我们的“[警告：]”印刷。它说这是一个警告。当然，我们有“你好！

112
00:09:08,008 --> 00:09:11,003
因此，让我们尝试打印一条信息消息。

113
00:09:11,004 --> 00:09:16,004
我还将打印“信息”Hello！“，并且还将打印错误”Hello！“。

114
00:09:17,005 --> 00:09:22,006
因此，我们在这里打印了三个不同的日志消息，或者更确切地说是相同的日志消息，但日志级别不同。

115
00:09:22,007 --> 00:09:28,003
您可以在此处看到，只有警告和错误被打印出来，信息不会，因为我们的级别当然设置为警告。

116
00:09:28,005 --> 00:09:33,006
如果我们从未设置日志级别，那么当然，它应该使用信息作为默认值，

117
00:09:33,007 --> 00:09:37,006
这意味着如果我运行这个，所有这三个都应该被打印出来，你可以看到它们确实如此。

118
00:09:37,006 --> 00:09:41,001
最后，让我们继续将该日志级别设置为错误。

119
00:09:41,001 --> 00:09:46,008
日志。LogLevelError，好吧，命中F5。您可以在这里看到，只有我们的错误被打印出来。

120
00:09:46,009 --> 00:09:50,008
好吧，很酷，所以我们已经完成了所有的目标。我们创建了一个非常非常基本的 Log 类。

121
00:09:50,009 --> 00:09:55,009
现在我只想说，这绝对不是我编写Log类的方式，绝对不是。

122
00:09:56,000 --> 00:09:59,000
这是相当可怕的代码，原因有几个，

123
00:09:59,000 --> 00:10:05,008
但它非常非常简单，并且从逻辑上讲，一个人可能会如何考虑编写这个类。

124
00:10:06,000 --> 00:10:09,005
当然，并不是一个有经验的程序员会怎么写这个的。

125
00:10:09,006 --> 00:10:13,009
我敢肯定，有很多人在看这个视频时，甚至都像是这样的代码。

126
00:10:13,009 --> 00:10:17,002
这不是漂亮的代码，但它够简单。

127
00:10:17,002 --> 00:10:21,001
如果你刚刚开始，希望你能理解这一切。

128
00:10:21,002 --> 00:10:28,002
这也给了我一个很好的借口，向你们展示我如何使用一些不同的概念来改进这个类，以及为什么这很糟糕。

129
00:10:28,003 --> 00:10:32,008
因此，在接下来的几集中，我们将花一些时间了解有关C++课程的更多信息。

130
00:10:32,008 --> 00:10:38,006
并进一步了解如何改进这一点，并使其成为我称之为专业或生产级代码的内容。

131
00:10:38,006 --> 00:10:42,008
但无论如何，感谢您观看此视频，我希望你们喜欢它。如果您这样做了，请点击喜欢按钮。

132
00:10:42,008 --> 00:10:46,002
你可以在Twitter和Instagram上关注我，了解我正在做的事情，

133
00:10:46,002 --> 00:10:51,008
如果你真的喜欢这个系列，并希望看到更多这样的剧集，你可以通过去 patreon.com/TheCherno 来支持我。

134
00:10:52,000 --> 00:10:54,002
您将可以访问新视频的草稿，

135
00:10:54,002 --> 00:10:59,001
以及一个讨论板，我们可以在其中讨论这些情节的实际内容。

136
00:10:59,001 --> 00:11:02,007
你可以在决定什么被抓住和留下什么方面有发言权。

137
00:11:02,008 --> 00:11:08,005
当然，支持此频道和这些视频的其他方法（对您完全免费）是获得Amazon Music Unlimited。

138
00:11:08,005 --> 00:11:13,006
链接在下面的描述中。这是一个非常棒的音乐流媒体服务，您可以免费试用三十天。

139
00:11:13,006 --> 00:11:16,000
下次再见。再见「フィユ~」

