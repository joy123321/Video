1
00:00:00,012 --> 00:00:00,024
嘿

2
00:00:00,024 --> 00:00:00,048
怎么了？

3
00:00:00,048 --> 00:00:00,074
伙计们

4
00:00:00,074 --> 00:00:01,078
我叫阿切罗

5
00:00:01,078 --> 00:00:03,054
欢迎收看今天的另一个视频

6
00:00:03,054 --> 00:00:07,028
我们将讨论C++中的函数，这是一个多么好的周中视频

7
00:00:07,028 --> 00:00:10,001
我是在做梦吗？没有发疯

8
00:00:10,001 --> 00:00:11,069
也许吧，但这不是重点

9
00:00:11,069 --> 00:00:12,077
我只想说一个巨大的

10
00:00:12,077 --> 00:00:14,045
感谢每一个喜欢这个系列的人

11
00:00:14,045 --> 00:00:16,009
我真的很高兴你们喜欢这个

12
00:00:16,009 --> 00:00:17,092
因为这是一个真正的爆炸

13
00:00:17,092 --> 00:00:20,024
如果你想告诉我你有多欣赏我的视频

14
00:00:20,024 --> 00:00:21,068
你可以在Instagram上关注我

15
00:00:21,068 --> 00:00:22,090
下面描述中的链接

16
00:00:22,090 --> 00:00:23,032
最近

17
00:00:23,032 --> 00:00:24,040
我真的很喜欢摄影

18
00:00:24,040 --> 00:00:25,056
这对我来说意味着整个世界

19
00:00:25,056 --> 00:00:26,064
如果你们能跟着我

20
00:00:26,064 --> 00:00:27,056
就像暂停

21
00:00:27,056 --> 00:00:28,052
现在这个视频

22
00:00:28,052 --> 00:00:30,067
无论如何都要跟着我

23
00:00:30,067 --> 00:00:31,092
返回函数

24
00:00:31,092 --> 00:00:33,050
那么函数到底是什么

25
00:00:33,050 --> 00:00:35,082
函数基本上是我们编写的代码块

26
00:00:35,082 --> 00:00:38,020
设计用于执行特定任务的

27
00:00:38,020 --> 00:00:38,074
后来

28
00:00:38,074 --> 00:00:39,086
当我们去上课的时候

29
00:00:39,086 --> 00:00:41,098
这些块被称为方法

30
00:00:41,098 --> 00:00:43,022
但当我说函数时

31
00:00:43,022 --> 00:00:46,045
我在明确地谈论一些不属于类的东西

32
00:00:46,045 --> 00:00:50,001
对我们来说，拆分函数以防止代码重复是很常见的

33
00:00:50,001 --> 00:00:53,004
我们不想多次运行相同的代码，因为

34
00:00:53,004 --> 00:00:53,036
当然啦

35
00:00:53,036 --> 00:00:55,096
如果我们除了复制和粘贴大量代码之外

36
00:00:55,096 --> 00:00:58,088
最后弄得一团糟

37
00:00:59,022 --> 00:01:02,032
这也意味着如果我们决定更改一些代码

38
00:01:02,032 --> 00:01:05,092
我们必须在所有我们粘贴原始代码的地方进行更改

39
00:01:05,092 --> 00:01:07,090
这将是一场灾难

40
00:01:07,090 --> 00:01:10,076
所以我们可以做的是写一个很好的小函数

41
00:01:10,076 --> 00:01:12,037
它做我们想让它做的事情

42
00:01:12,037 --> 00:01:14,041
然后我们可以在代码中多次调用它

43
00:01:14,041 --> 00:01:15,019
如果我们需要

44
00:01:15,019 --> 00:01:18,012
您可以将函数看作具有输入和输出

45
00:01:18,012 --> 00:01:20,008
虽然他们不一定需要

46
00:01:20,008 --> 00:01:24,064
我们可以为函数提供某些参数，函数可以为我们返回值

47
00:01:24,064 --> 00:01:27,064
假设我们要把两个数相乘

48
00:01:27,064 --> 00:01:29,080
我们想写一个函数来做到这一点

49
00:01:29,080 --> 00:01:32,062
所以我在这里要写的第一件事是一个返回值

50
00:01:32,062 --> 00:01:35,051
即这是此函数将返回的类型

51
00:01:35,051 --> 00:01:37,023
因为我们是两个整数的乘法

52
00:01:37,023 --> 00:01:39,005
这当然会导致一个整数

53
00:01:39,005 --> 00:01:40,073
所以我们的返回类型是int

54
00:01:40,073 --> 00:01:42,015
我要给函数起一个名字

55
00:01:42,015 --> 00:01:43,060
在这种情况下乘法

56
00:01:43,098 --> 00:01:45,078
它需要两个参数

57
00:01:45,078 --> 00:01:48,044
这些实际上是我们要相乘的数字

58
00:01:48,044 --> 00:01:50,025
我就叫他们A和B

59
00:01:50,025 --> 00:01:51,045
我会给这个功能一个身体

60
00:01:51,045 --> 00:01:54,092
所有要做的就是返回a乘以b

61
00:01:54,092 --> 00:01:57,080
你可以看到我们这里有一个函数，它接受两个参数

62
00:01:57,080 --> 00:02:01,043
都是整数，并简单地返回这两个数字的乘积

63
00:02:01,043 --> 00:02:03,075
我们不一定要提供参数

64
00:02:03,075 --> 00:02:04,039
比如说

65
00:02:04,039 --> 00:02:08,061
我不能提供任何参数，返回大约5乘以8

66
00:02:08,061 --> 00:02:11,049
这仍然是一个返回整数的函数

67
00:02:11,049 --> 00:02:13,075
但它只是不考虑任何参数

68
00:02:13,075 --> 00:02:16,085
我们还可以告诉函数，我们不希望它返回任何东西

69
00:02:16,085 --> 00:02:18,037
我们通过写void来做到这一点

70
00:02:18,037 --> 00:02:21,022
因为它的返回类型void当然没有任何意义，所以相反

71
00:02:21,022 --> 00:02:22,038
这可以做一些类似日志的事情

72
00:02:22,038 --> 00:02:24,000
将结果发送到控制台

73
00:02:26,034 --> 00:02:28,070
所以让我们回到我们最初的例子

74
00:02:28,070 --> 00:02:33,084
我们有int a和int b，我们返回这两个整数的乘积

75
00:02:33,084 --> 00:02:36,007
那么我们如何调用这个函数呢

76
00:02:36,007 --> 00:02:37,092
调用函数非常简单

77
00:02:37,092 --> 00:02:40,050
让我们继续试着打印乘法的结果

78
00:02:40,050 --> 00:02:43,042
我首先要做一个变量来保存这个结果

79
00:02:43,042 --> 00:02:46,002
所以我将输入最终结果等于乘法

80
00:02:46,008 --> 00:02:48,030
我们要三二

81
00:02:48,030 --> 00:02:52,054
我们要做的就是用这两个参数调用这个乘法函数

82
00:02:52,054 --> 00:02:54,032
然后存储返回值

83
00:02:54,032 --> 00:02:58,050
这是这个结果整数中a乘以b的结果

84
00:02:58,050 --> 00:03:01,018
然后我们可以将结果输出到控制台

85
00:03:01,018 --> 00:03:02,097
让我们击个5来运行我们的程序

86
00:03:02,097 --> 00:03:03,093
在它建成之后

87
00:03:03,093 --> 00:03:04,095
你可以看到我们有六个

88
00:03:04,095 --> 00:03:07,016
这当然是三乘二的结果

89
00:03:07,016 --> 00:03:08,068
所以让我们把这个提升一个档次

90
00:03:08,068 --> 00:03:10,066
假设我想做一堆乘法

91
00:03:10,066 --> 00:03:13,024
我想把它们都记录到控制台

92
00:03:13,024 --> 00:03:15,028
如果我在没有功能的情况下做了这样的事情

93
00:03:15,028 --> 00:03:16,038
那看起来就很乱了

94
00:03:16,038 --> 00:03:17,008
例如

95
00:03:17,008 --> 00:03:18,046
我需要重复这个代码

96
00:03:18,046 --> 00:03:21,027
所以让我们继续复制粘贴几次

97
00:03:21,027 --> 00:03:22,091
我把它叫做结果二

98
00:03:22,091 --> 00:03:23,096
结果三

99
00:03:24,012 --> 00:03:26,050
我们将做八乘五

100
00:03:26,050 --> 00:03:28,088
九十乘以四五

101
00:03:28,088 --> 00:03:30,022
如果我运行我的程序

102
00:03:30,022 --> 00:03:31,096
哦，等一下

103
00:03:31,096 --> 00:03:33,044
为什么我在任何地方都得到相同的值

104
00:03:33,044 --> 00:03:33,094
哦快看

105
00:03:33,094 --> 00:03:35,020
当我复制粘贴此代码时

106
00:03:35,020 --> 00:03:37,002
我忘了换变量

107
00:03:37,002 --> 00:03:38,096
现在你可能认为我那样做是偶然的

108
00:03:38,096 --> 00:03:40,020
但我其实是故意的

109
00:03:40,020 --> 00:03:41,024
证明什么

110
00:03:41,024 --> 00:03:44,050
这其实一直都在发生

111
00:03:44,050 --> 00:03:46,030
人们复制和粘贴代码块

112
00:03:46,030 --> 00:03:49,008
然后忘记改变一个小细节

113
00:03:49,008 --> 00:03:52,016
在某些情况下，你可能会运行你的程序

114
00:03:52,016 --> 00:03:54,048
甚至没有注意到它不能正常工作

115
00:03:54,048 --> 00:03:57,028
直到它在线路的某个地方破裂

116
00:03:57,028 --> 00:03:59,085
然而，像这样的事情实际上可以很容易地修复

117
00:03:59,085 --> 00:04:01,023
如果你只是为它创建一个函数

118
00:04:01,023 --> 00:04:04,013
所以让我们继续通过打印结果2和3来解决这个问题

119
00:04:04,013 --> 00:04:05,016
如果我运行这个

120
00:04:05,016 --> 00:04:06,046
我们会得到正确的结果

121
00:04:06,046 --> 00:04:07,012
这是伟大的

122
00:04:07,012 --> 00:04:09,088
然而，你可以看到，我实际上调用了多次

123
00:04:09,088 --> 00:04:11,080
只是有点烦人

124
00:04:11,080 --> 00:04:12,054
比如

125
00:04:12,054 --> 00:04:13,062
在路的更远的地方

126
00:04:13,062 --> 00:04:19,023
如果我决定用8乘以5来代替这个乘法函数

127
00:04:19,023 --> 00:04:19,087
看看这个

128
00:04:19,087 --> 00:04:22,003
我必须在每一个地方更换它

129
00:04:22,003 --> 00:04:23,042
三乘二

130
00:04:23,066 --> 00:04:25,020
九十乘以四五

131
00:04:25,020 --> 00:04:25,050
那是

132
00:04:25,050 --> 00:04:26,074
我不想处理那件事

133
00:04:26,074 --> 00:04:29,036
所以这个乘法然后记录结果

134
00:04:29,036 --> 00:04:31,027
让我们继续为它做一个函数

135
00:04:31,027 --> 00:04:32,011
它将是空的

136
00:04:32,011 --> 00:04:34,009
因为它不会真的把任何东西还给我们

137
00:04:34,009 --> 00:04:36,059
它只是执行我们要求它做的事情

138
00:04:36,059 --> 00:04:39,006
我们称之为乘法和对数

139
00:04:39,006 --> 00:04:41,043
然后让我们看看我们可能需要哪些参数

140
00:04:41,043 --> 00:04:44,081
那么在这三个代码块之间实际更改的是什么

141
00:04:44,081 --> 00:04:46,071
我们实际乘以的值

142
00:04:46,071 --> 00:04:47,048
就是这样

143
00:04:47,048 --> 00:04:50,063
所以这些成为我们函数的参数

144
00:04:50,063 --> 00:04:53,005
在这些代码块之间实际更改的是什么

145
00:04:53,005 --> 00:04:55,094
需要为此函数指定什么才能执行其工作

146
00:04:55,094 --> 00:04:57,070
让我们继续写我们的参数

147
00:04:57,070 --> 00:04:59,028
所以我们将接受两个整数

148
00:04:59,028 --> 00:04:59,088
a和b

149
00:04:59,088 --> 00:05:01,032
你真的可以叫他们任何你想叫的

150
00:05:01,032 --> 00:05:02,062
但A和B似乎很明智

151
00:05:02,062 --> 00:05:04,095
我们将复制并粘贴其中一个块到这个函数中

152
00:05:04,095 --> 00:05:05,075
这看起来很不错

153
00:05:05,075 --> 00:05:08,013
当然，我会用我们的参数代替3和2

154
00:05:08,013 --> 00:05:11,016
所以我们使用我们在这个函数中指定的参数

155
00:05:11,016 --> 00:05:14,092
执行乘法，使a乘以b在这里相乘

156
00:05:14,092 --> 00:05:17,016
然后我们将把结果记录到控制台

157
00:05:17,016 --> 00:05:19,099
所以现在不要做这么多次

158
00:05:19,099 --> 00:05:25,060
我所要做的就是简单地调用乘法并用我的参数记录

159
00:05:25,060 --> 00:05:26,042
所以三和二

160
00:05:26,042 --> 00:05:27,012
比如说

161
00:05:27,012 --> 00:05:30,014
然后我们有八个和五个

162
00:05:30,086 --> 00:05:34,070
然后我们有九四十五

163
00:05:35,060 --> 00:05:38,026
就是这样，看，我可以摆脱所有这些代码

164
00:05:38,026 --> 00:05:41,086
这就是我们最终得到的一个干净易读的程序

165
00:05:41,086 --> 00:05:43,077
如果我启动我的程序

166
00:05:43,077 --> 00:05:46,048
你可以看到我们在这里得到了正确的值

167
00:05:46,048 --> 00:05:47,096
这是一个非常简单的例子

168
00:05:47,096 --> 00:05:51,040
但我认为它有效地证明了功能是非常非常重要的

169
00:05:51,040 --> 00:05:54,070
你的目标应该是把你的代码分成很多很多的函数

170
00:05:54,070 --> 00:05:57,030
然而，我想强调的一点是，不要过火

171
00:05:57,030 --> 00:05:58,054
你不需要一个函数

172
00:05:58,054 --> 00:06:02,067
绝对每一行代码对任何人都没有好处

173
00:06:02,067 --> 00:06:04,005
很难维持

174
00:06:04,005 --> 00:06:06,019
您的代码将看起来凌乱和杂乱

175
00:06:06,019 --> 00:06:08,013
它实际上会使你的程序变慢

176
00:06:08,013 --> 00:06:10,056
每次我们调用函数星号

177
00:06:10,056 --> 00:06:12,061
编译器生成调用指令

178
00:06:12,061 --> 00:06:15,074
这基本上意味着在一个运行的程序中

179
00:06:15,074 --> 00:06:17,057
为了让我们调用函数

180
00:06:17,057 --> 00:06:20,048
我们需要为函数创建整个堆栈框架

181
00:06:20,048 --> 00:06:23,018
这意味着我们必须把参数之类的东西推到堆栈上

182
00:06:23,018 --> 00:06:25,091
我们还必须把一个叫做返回地址的东西推到堆栈上

183
00:06:25,091 --> 00:06:29,089
然后我们要做的是跳转到二进制的不同部分

184
00:06:29,089 --> 00:06:32,098
以便开始执行我们函数中的指令

185
00:06:32,098 --> 00:06:34,046
我们推送的返回值

186
00:06:34,046 --> 00:06:37,050
我们需要回到我们最初调用函数之前的位置

187
00:06:37,050 --> 00:06:41,034
这就像是为了执行函数指令而在内存中跳来跳去

188
00:06:41,034 --> 00:06:42,088
所有这些都需要时间

189
00:06:42,088 --> 00:06:44,010
所以它减慢了我们的程序

190
00:06:44,010 --> 00:06:44,036
现在

191
00:06:44,036 --> 00:06:46,020
我之前说星号的原因是

192
00:06:46,020 --> 00:06:47,044
因为这都是假设

193
00:06:47,044 --> 00:06:50,004
编译器决定将我们的函数保留为实际函数

194
00:06:50,004 --> 00:06:51,026
并不符合它

195
00:06:51,026 --> 00:06:53,090
我们将在以后的视频中深入讨论In衬里

196
00:06:53,090 --> 00:06:55,022
所以我说这一切的原因是

197
00:06:55,022 --> 00:06:57,076
因为您不想继续为

198
00:06:57,076 --> 00:06:58,094
绝对每一行代码

199
00:06:58,094 --> 00:07:00,032
别傻了

200
00:07:00,032 --> 00:07:03,041
需要一点经验才能意识到你需要一个函数来做什么

201
00:07:03,041 --> 00:07:07,042
但基本上如果你看到自己多次做一项常见的任务

202
00:07:07,042 --> 00:07:08,062
为此创建一个函数

203
00:07:08,062 --> 00:07:12,034
函数的主要目的是防止代码重复

204
00:07:12,034 --> 00:07:16,069
我们不想到处复制粘贴代码

205
00:07:16,069 --> 00:07:16,093
现在

206
00:07:16,093 --> 00:07:18,061
如果我们回到我们的代码

207
00:07:18,061 --> 00:07:21,081
您可能已经注意到这个主函数有点奇怪

208
00:07:21,081 --> 00:07:24,005
它说它的返回值是int

209
00:07:24,005 --> 00:07:24,061
然而

210
00:07:24,061 --> 00:07:27,007
返回关键字无处可寻

211
00:07:27,007 --> 00:07:29,080
我显然不会归还任何东西

212
00:07:29,080 --> 00:07:32,002
所以如果我指定返回值

213
00:07:32,002 --> 00:07:34,011
我真的需要退货吗

214
00:07:34,011 --> 00:07:36,077
让我们继续，试着在这个乘法函数中什么都不做

215
00:07:36,077 --> 00:07:38,061
我会按ctrl f 7编译我的文件

216
00:07:38,061 --> 00:07:39,011
看看这个

217
00:07:39,011 --> 00:07:39,087
我得到一个错误

218
00:07:39,087 --> 00:07:41,098
告诉我乘法必须返回值

219
00:07:41,098 --> 00:07:44,096
返回类型的函数实际上需要返回值

220
00:07:44,096 --> 00:07:46,032
答案是肯定的

221
00:07:46,032 --> 00:07:49,072
他们做的主要功能实际上是一个特殊的功能

222
00:07:49,072 --> 00:07:54,026
主要功能，只有主要功能不受这种

223
00:07:54,026 --> 00:07:55,044
必须返回值

224
00:07:55,044 --> 00:07:57,026
如果不指定返回值

225
00:07:57,026 --> 00:07:59,070
它会自动假设你返回零

226
00:07:59,070 --> 00:08:00,098
所以它会和

227
00:08:00,098 --> 00:08:02,008
如果我写了这个

228
00:08:02,008 --> 00:08:04,078
这只是现代C和C Plus版本的一个特性

229
00:08:04,078 --> 00:08:08,036
这让您只需保持代码更干净一点，只是为了好玩

230
00:08:08,036 --> 00:08:10,026
知道这必须返回一个值

231
00:08:10,026 --> 00:08:13,012
实际上只适用于调试模式

232
00:08:13,012 --> 00:08:14,072
如果我们在这里编译和发布模式

233
00:08:14,072 --> 00:08:16,057
你会看到我们实际上没有得到错误

234
00:08:16,057 --> 00:08:18,080
这并不是说我们在这里所做的是正确的

235
00:08:18,080 --> 00:08:22,038
因为如果我们真的捕获了返回值并决定做一些事情

236
00:08:22,038 --> 00:08:23,052
我们会得到未定义的行为

237
00:08:23,052 --> 00:08:26,016
只是编译器实际上不会对我们大喊大叫

238
00:08:26,016 --> 00:08:26,056
然而

239
00:08:26,056 --> 00:08:30,057
在调试模式下，启用了某些调试编译标志

240
00:08:30,057 --> 00:08:32,006
我们会得到一个错误

241
00:08:32,006 --> 00:08:34,002
这将帮助我们调试代码

242
00:08:34,002 --> 00:08:37,004
因为在任何时候，您都不应该编写一个函数，说

243
00:08:37,004 --> 00:08:37,090
它会返回一些东西

244
00:08:37,090 --> 00:08:39,034
但是不行

245
00:08:39,034 --> 00:08:42,025
这几乎是对函数的基本介绍

246
00:08:42,025 --> 00:08:43,059
函数真的很有用

247
00:08:43,059 --> 00:08:46,007
我将来会写更多的书

248
00:08:46,007 --> 00:08:48,073
每个程序都是由函数集合构建的

249
00:08:48,073 --> 00:08:50,059
所以这真的很重要

250
00:08:50,059 --> 00:08:53,007
如果你不认为你完全理解函数是如何工作的

251
00:08:53,007 --> 00:08:53,075
别担心

252
00:08:53,075 --> 00:08:56,075
因为在本系列中，我们将编写许多函数

253
00:08:56,075 --> 00:08:57,087
你会习惯的

254
00:08:57,087 --> 00:08:58,095
最好的学习方法是

255
00:08:58,095 --> 00:08:59,066
当然是练习

256
00:08:59,066 --> 00:09:03,054
我们还通常将函数分解为声明和定义

257
00:09:03,054 --> 00:09:06,008
所以我们通常存储在头文件中的声明

258
00:09:06,008 --> 00:09:09,036
然后我们在翻译单元或CPP文件中编写定义

259
00:09:09,036 --> 00:09:12,008
所以我要做一个完整的视频专用于头文件

260
00:09:12,008 --> 00:09:16,016
我们将在视频中介绍头文件中的函数声明

261
00:09:16,016 --> 00:09:16,078
但不管怎样

262
00:09:16,078 --> 00:09:16,094
伙计们

263
00:09:16,094 --> 00:09:18,024
我希望你喜欢这一集

264
00:09:18,024 --> 00:09:18,084
如果你做了

265
00:09:18,084 --> 00:09:19,076
给个三连吧

266
00:09:19,076 --> 00:09:22,010
别忘了在推特和Instagram上关注我

267
00:09:22,010 --> 00:09:23,042
如果你真的喜欢这个视频

268
00:09:23,042 --> 00:09:25,088
你想早点看到未来视频的草稿

269
00:09:25,088 --> 00:09:28,071
以及讨论这些视频中的内容

270
00:09:28,071 --> 00:09:30,007
你可以在Patreon上支持我

271
00:09:30,007 --> 00:09:31,035
链接将在下面的描述中

272
00:09:31,035 --> 00:09:32,025
但直到下一次

273
00:09:32,025 --> 00:09:32,059
伙计们

274
00:09:32,059 --> 00:09:33,052
再见

