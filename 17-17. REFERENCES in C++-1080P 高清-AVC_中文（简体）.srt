1
00:00:01,010 --> 00:00:06,090
大家好！ 我们今天来聊聊引用（reference）

2
00:00:06,090 --> 00:00:12,060
上周我们聊了指针，如果你没有看那期视频那你千万一定要去看

3
00:00:12,060 --> 00:00:16,030
因为事实上引用（reference）只是指针的一个扩展

4
00:00:16,030 --> 00:00:23,040
所以你要对于指针如何运作有所了解，才能听懂这期的内容。

5
00:00:23,040 --> 00:00:28,040
所以逃课的少年去补课吧

6
00:00:28,050 --> 00:00:33,050
ok，指针和引用是在c++和其他语言中常被提及的两种关键字

7
00:00:33,060 --> 00:00:36,030
它们实际上是一回事（叹气）

8
00:00:36,032 --> 00:00:43,050
我录这期视频只是想阐述，在计算机如何处理这两种关键字的角度看，指针和引用基本上是一回事

9
00:00:43,050 --> 00:00:48,050
当然，我们如何写它们，怎么用它们还是有一些不同的。

10
00:00:48,070 --> 00:00:54,070
但是最终来看，引用就是指针，他俩就是一回事

11
00:00:54,070 --> 00:01:00,010
引用只是基于指针的一种高级修饰（翻译不能），来使得代码更易读更好学而已。

12
00:01:00,010 --> 00:01:05,070
引用，和他的名字一样，是指对某个已存在的变量的引用。

13
00:01:05,070 --> 00:01:14,060
对于指针来说，你可以先创建一个指针变量并给他赋值nullptr或者其他等于0的量，但引用不能这么做。 

14
00:01:14,060 --> 00:01:20,090
因为“引用变量”必须引用一个已存在的变量，它本身并不是一个新的变量。

15
00:01:20,090 --> 00:01:24,020
它们并不真正占用内存

16
00:01:24,020 --> 00:01:28,040
它们不像你之前用的典型的变量那样存储数据。

17
00:01:28,040 --> 00:01:32,010
因为它只是其他变量的引用而不是一个真正的变量。

18
00:01:32,010 --> 00:01:35,080
这期视频我会给大家带来几个例子，但也会尽量简短

19
00:01:36,016 --> 00:01:41,040
因为引用并没有那么复杂，而且学习引用最好的办法就是去多写几行代码。

20
00:01:41,040 --> 00:01:44,050
而且在这个系列中我一直都会用到这种关键字

21
00:01:44,050 --> 00:01:47,070
然后你就能明白在哪里引用最好

22
00:01:47,070 --> 00:01:50,090
或者至少是了解我所认为的引用最佳的应用场景

23
00:01:50,090 --> 00:01:52,069
不管了，看代码吧

24
00:01:52,069 --> 00:01:57,010
比如说我创建一个整形变量 a 等于 5

25
00:01:57,010 --> 00:02:00,060
如果我想创建这个变量的引用，我可以这样写

26
00:02:00,080 --> 00:02:06,050
敲变量类型，紧跟着&符号，声明中间不要加任何其他字符（空格）

27
00:02:06,050 --> 00:02:17,020
上一期关于指针的视频我们学到，&加在已存在的变量前可以指向它的内存地址

28
00:02:17,020 --> 00:02:22,020
在这不一样，&符号实际上是变量类型的一部分

29
00:02:22,020 --> 00:02:26,093
这里他不是贴着一个已存在的变量，他是变量类型的一部分

30
00:02:26,093 --> 00:02:28,020
记住这个不同点

31
00:02:28,020 --> 00:02:35,088
并不是有&就一定是指针或一定是引用，要看他前后的字符是什么

32
00:02:35,088 --> 00:02:38,052
在这里因为他挨着变量类型，所以是引用

33
00:02:38,052 --> 00:02:41,035
我们接着写，给这个引用命名 ref ，让它等于 a 

34
00:02:41,035 --> 00:02:47,007
这就是所有需要做的事，在这儿不用写任何那些奇怪的操作符

35
00:02:47,007 --> 00:02:49,062
就是让它等于一个已存在的变量即可

36
00:02:49,062 --> 00:02:53,030
到现在为止，我们就创建了一个别名（alias）

37
00:02:53,052 --> 00:03:00,035
因为这个ref  "变量" ，加引号意思是它其实不是变量，只是一个别称

38
00:03:00,056 --> 00:03:05,012
这个 ref 变量并不真正存在，它只存在在我们的源码里

39
00:03:05,012 --> 00:03:11,020
如果你现在编译这个程序，你不会创建两个变量a和ref，只有a

40
00:03:11,020 --> 00:03:14,025
我们现在能做的，就是把ref当a一样使用。

41
00:03:14,025 --> 00:03:17,007
我们设置ref 等于2 

42
00:03:17,007 --> 00:03:19,073
然后输出 a 的值

43
00:03:19,073 --> 00:03:23,075
跑下试试，你会看到a的值现在是2了

44
00:03:23,075 --> 00:03:26,005
因为我们刚刚把ref 也就是 a 改成了2

45
00:03:26,005 --> 00:03:31,005
在任何情况下，ref 就是 a，我们只是给 a 创建了一个别名

46
00:03:31,011 --> 00:03:36,070
在这个例子里，我们的引用不是一个指针，编译器没有必要创建一个新的变量

47
00:03:36,070 --> 00:03:42,018
如果你编译程序，到最后a等于2，因为那就是我们做的事

48
00:03:42,028 --> 00:03:47,028
这只是我们在源码里的一种操作，如果我们希望给某个变量一个别名，引用能让写代码更好写一点

49
00:03:47,040 --> 00:03:49,068
现在我们搞点稍微复杂的

50
00:03:49,068 --> 00:03:53,010
假设我们想要一个函数，使得输入的整数递增

51
00:03:53,010 --> 00:03:59,073
如果我们这样写，然后这样写

52
00:03:59,073 --> 00:04:07,018
如果我创建个整形变量a在这里，然后调用这个函数，把a放进去作为参数

53
00:04:07,018 --> 00:04:14,005
这里将要发生的是，由于我们是传值调用（passing by value），你可以看到这里不是指针或者引用

54
00:04:14,005 --> 00:04:17,085
所以调用过程中程序将会拷贝参数值5到这个函数里

55
00:04:17,085 --> 00:04:20,092
直接拷贝，这将会创造一个全新的变量value


56
00:04:20,092 --> 00:04:24,000
就像是这样直接声明并赋值一个变量

57
00:04:24,000 --> 00:04:26,008
这两者是完全一样的

58
00:04:26,008 --> 00:04:34,027
这很好证明，这里我的值输出是5（a没有增加，只是value增加了）

59
00:04:34,027 --> 00:04:39,095
我需要的是引用传递（passing by reference）这个变量来让他递增

60
00:04:39,095 --> 00:04:45,062
因为我真正想做的是影响这个变量a，所以我该怎么做呢？

61
00:04:45,062 --> 00:04:49,090
怎么做才能通过把变量传递进函数来真正改变这个变量的值呢？

62
00:04:49,090 --> 00:04:54,083
上次我们说到指针是内存地址，所以理论上讲

63
00:04:54,083 --> 00:04:57,017
这里我希望你可以把这些知识在大脑里融合一下这可太亦可赛艇了

64
00:04:57,017 --> 00:05:00,090
理论上讲，我们可以做的事是，我们很聪明对吧~

65
00:05:00,090 --> 00:05:07,038
我们可以不传递5这个值进函数里，而是直接传递a这个变量的地址

66
00:05:07,038 --> 00:05:14,008
因为我们可以在函数里找到这个变量地址，看到数字5，然后加以更改

67
00:05:14,008 --> 00:05:18,020
我们可以通过内存地址完成写入，因为我们把内存地址传进了函数


68
00:05:18,020 --> 00:05:19,018
来我们康康

69
00:05:19,018 --> 00:05:24,045
我将要做的是把函数的形参变为一个指针，就还叫它value吧

70
00:05:24,045 --> 00:05:31,023
在调用函数的时候我会将a的内存地址而不是a本身传递给函数

71
00:05:31,023 --> 00:05:34,020
它现在就是在传递变量的内存地址了


72
00:05:34,020 --> 00:05:41,048
还有一件事必须做，就是要把这里改成解引用的形式从而改变地址存储的数值，而不是地址本身

73
00:05:41,048 --> 00:05:46,025
如果只有高亮的部分的话，递增的就是地址本身了对吧~

74
00:05:46,025 --> 00:05:57,065
指针就是地址，实质是一个整数，如果直接在它后面++而不在前面带星号的话，它就会增加内存地址本身而不是实际的数值

75
00:05:57,067 --> 00:06:06,035
现在，由于操作符的优先级，递增符号会优先执行，所以我在这里加一个括号来保证先解引用，再递增


76
00:06:06,035 --> 00:06:12,067
因为我不想先增加地址，再解引用；我想先解引用，再递增那个地址的数值
（一直说的是一个意思）

77
00:06:12,073 --> 00:06:17,010
所以如果我编译代码，你能看到结果变成了6 

78
00:06:17,010 --> 00:06:20,083
太棒辣！我们成功地通过引用传递了一个参数进函数中

79
00:06:20,083 --> 00:06:26,035
但是，这个视频是关于引用的，所以如果使用引用的话，我们可以更简单地实现之前我们做的事情

80
00:06:26,035 --> 00:06:30,012
用更少的代码，也不用各种对变量名的装饰

81
00:06:30,012 --> 00:06:32,072
我在这种情况下就会使用引用

82
00:06:32,072 --> 00:06:37,008
我们可以把这里的指针形参改成引用的形式

83
00:06:37,008 --> 00:06:42,008
这样做的好处是，我可以扔掉这里的解引用，改回原来的样子

84
00:06:42,008 --> 00:06:45,090
在这里我也不需要传递变量的地址，我只需要传递a

85
00:06:45,090 --> 00:06:50,005
由于它是引用传递（passed by reference）的，我们实际上重写了代码并做了完全相同的事情

86
00:06:50,005 --> 00:06:55,005
最终编译之后，他们的结果将是完全相同的

87
00:06:55,005 --> 00:06:57,042
只不过这一次我们的源码看起来更nice了

88
00:06:57,042 --> 00:06:59,035
再说一遍，这是唯一的区别。

89
00:06:59,035 --> 00:07:02,027
我们跑一下程序，你能看到我们得到了6（用力敲回车）

90
00:07:02,027 --> 00:07:04,077
好了，这就是关于引用的全部了

91
00:07:04,077 --> 00:07:11,052
它只是让代码更好看而已，没有任何事情是引用能做但指针不能的

92
00:07:11,052 --> 00:07:15,098
指针很像引用，但是它们更有用也更强大。

93
00:07:15,098 --> 00:07:20,033
但是如果你能学会使用引用的方法，就像我们在这儿做的，那一定要用

94
00:07:20,038 --> 00:07:23,067
因为这会让你的代码变得干净和简单很多，更有可读性

95
00:07:23,067 --> 00:07:28,067
不像指针会让程序很难懂，引用会让源码看起来干净很多

96
00:07:28,073 --> 00:07:34,080
还有一件重要的事就是一旦你声明了一个引用，你就不能更改它所引用的对象

97
00:07:34,083 --> 00:07:39,083
我的意思是，假设我有两个整数，我有a和b

98
00:07:39,080 --> 00:07:44,080
b等于8，a等于5；

99
00:07:44,080 --> 00:07:49,080
我想声明ref等于a，然后等下我将ref声明变为b

100
00:07:51,045 --> 00:07:54,015
我可以这么做吗？答案是不行

101
00:07:54,023 --> 00:08:04,027
这里将发生的是你会把b赋值给ref （a现在等于8了）

102
00:08:04,040 --> 00:08:09,070
所以现在a=8， b=8

103
00:08:09,085 --> 00:08:12,015
这就是你最终得到的

104
00:08:12,075 --> 00:08:17,092
而且当然，这也意味着当你声明一个引用时，你必须将一个实际的变量赋值给它

105
00:08:18,010 --> 00:08:20,023
你不能这样做（只声明不赋值）


106
00:08:20,032 --> 00:08:23,080
能看到编译器不允许代码通过，需要初始化引用变量

107
00:08:23,080 --> 00:08:27,092
当你声明一个引用时，你必须立刻给它赋值，因为它必须是某物的引用

108
00:08:27,092 --> 00:08:30,050
记住它是引用，不是真的变量

109
00:08:30,084 --> 00:08:38,033
所以在这个例子里，如果我确实想改变ref所指代的是什么该怎么办呢？

110
00:08:38,033 --> 00:08:41,045
当然像我之前提到的，这不是一个真正的变量

111
00:08:41,045 --> 00:08:47,033
我们需要创建一些变量使得它先指向a，然后再让它指向b

112
00:08:47,033 --> 00:08:51,085
其实我一直说指向是希望你能明白我想用指针

113
00:08:51,085 --> 00:08:54,035
所以，把这里改掉，声明一个指针

114
00:08:54,035 --> 00:08:59,057
我们先让它指向a，再让它指向b

115
00:08:59,057 --> 00:09:01,050
我们可以让它像这样切换

116
00:09:01,050 --> 00:09:08,000
因为如果想要改变指针指向的值，我需要首先解引用

117
00:09:08,000 --> 00:09:09,047
然后才能给它赋值

118
00:09:09,047 --> 00:09:15,055
所以在这个例子里，我将要让a等于2，让b等于1

119
00:09:15,080 --> 00:09:21,005
如果我想把两个变量的值都输出出来，应该是2 和 1

120
00:09:21,005 --> 00:09:23,038
可以看到，确实是

121
00:09:23,038 --> 00:09:25,053
好了，这就是我要说的了，很简单的东西

122
00:09:25,053 --> 00:09:36,033
我们会在将来大量的用引用，包括指针等关键字，所以你会在这个系列的将来看到更多例子

