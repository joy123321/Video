1
00:00:00,007 --> 00:00:04,007
嘿，大家好！我是Cherno，欢迎回到我的C++系列课程

2
00:00:04,007 --> 00:00:07,053
这将会是简短的一集，仅仅基于回答下面这一个问题

3
00:00:07,054 --> 00:00:11,005
在C++中结构体和类的区别是什么？

4
00:00:11,007 --> 00:00:13,056
上次我们大概的讨论了一下类

5
00:00:13,062 --> 00:00:18,060
我们对什么是类有了一些基础的理解，如果还有谁没看过那期视频的

6
00:00:18,067 --> 00:00:22,041
在描述下方会有相应的链接或者是一些奇怪的注释

7
00:00:22,042 --> 00:00:25,027
我想或许叫它们为卡片？它们应该是屏幕上某处的一个卡片

8
00:00:25,036 --> 00:00:31,045
但是我们在C++中有这两个术语，结构（structure）的缩写struct和class

9
00:00:31,048 --> 00:00:37,062
它们或许看起来有些相似，很多人对它们之间的区别感到困惑

10
00:00:37,075 --> 00:00:42,060
什么时候你应当使用struct，什么时候又应当用class，这个视频将会解决这个问题

11
00:00:42,062 --> 00:00:45,030
所以不同···
是这个

12
00:00:45,041 --> 00:00:46,095
基本上没有区别

13
00:00:46,097 --> 00:00:51,053
显而易见的只有一个小小的区别，上次当我谈论

14
00:00:51,055 --> 00:00:57,055
我们如何能让一个类的成员在默认情况下是私有的，这意味着如果我要做这样的事情

15
00:00:57,057 --> 00:00:59,055
然而，我没有

16
00:00:59,060 --> 00:01:01,020
声明它为公有的

17
00:01:01,036 --> 00:01:07,043
然后我们会得到一个错误，我们会看到它说因为在Player类里的Move是无法访问的

18
00:01:07,044 --> 00:01:14,030
因为按照预置值它被标记为私有，这意味着只有在这个类里的其他方法才能访问Move

19
00:01:14,036 --> 00:01:19,078
这就是为什么如果我们想要执行这段代码，我们不得不在这里写上public，因为当我们调用player

20
00:01:19,085 --> 00:01:24,055
Move在player类之外，这就是本质上的区别

21
00:01:24,089 --> 00:01:27,028
默认情况下，类是私有的

22
00:01:27,028 --> 00:01:32,093
所以如果你没有像我这样在这里指定任何类型的可见修饰符，如果你不摆脱它

23
00:01:32,093 --> 00:01:37,030
或者你没有指定任何内容，默认就会是私有的

24
00:01:37,032 --> 00:01:42,085
然而struct默认是公有的，这就是结构体和类的唯一区别

25
00:01:42,088 --> 00:01:48,020
严格地说。你可以在这里看到我们的代码中得到一个错误，还是因为Move是不可访问的

26
00:01:48,021 --> 00:01:54,025
但是，如果我将这里改成为struct player，也就是说，我只是将class改成了struct，这就是我所做的

27
00:01:54,025 --> 00:01:58,015
现在一切正常。如果我想要一些变成private

28
00:01:58,020 --> 00:02:00,060
我必须明确的写private

29
00:02:00,064 --> 00:02:05,053
然后我们会得到一个刚刚使用类时相同的错误，这就是区别

30
00:02:05,054 --> 00:02:06,093
这很简单

31
00:02:07,004 --> 00:02:11,056
这就是全部。但是，与其仅仅发布一个两分钟的视频

32
00:02:11,060 --> 00:02:18,056
我想谈谈我们如何定义这两个词之间的差别

33
00:02:18,060 --> 00:02:26,090
因为就像作用上讲它们并没有太大区别，但是在代码实际使用时确实有所不同

34
00:02:26,099 --> 00:02:30,035
在C++中结构体存在的唯一原因

35
00:02:30,051 --> 00:02:37,000
是因为它想要维持与C之间的兼容性，因为C中没有类

36
00:02:37,007 --> 00:02:42,005
然而它有结构体，如果我们突然彻底删除struct这个关键字

37
00:02:42,005 --> 00:02:44,095
那样我们就会失去所有的兼容性

38
00:02:45,005 --> 00:02:51,085
因为C++的编译器不知道什么是struct，当然你可以通过使用“#”来很容易的修复它

39
00:02:52,008 --> 00:02:56,043
我们可以写上一些类似# define struct class的语句，对吧？

40
00:02:56,053 --> 00:03:01,045
然后它瞬间把所有的struct替换成了class

41
00:03:01,045 --> 00:03:04,048
所以在这种情况下，即使代码看起来相当

42
00:03:04,056 --> 00:03:09,020
相当简洁，如果我编译它，你会发现我们我们得到了同样的错误告诉我们

43
00:03:09,030 --> 00:03:14,030
即使我们在这里使用struct，也不能再类中访问move，当然是因为它

44
00:03:14,031 --> 00:03:17,023
替换struct为单词class，也许是的。

45
00:03:17,023 --> 00:03:20,056
你可以在C代码与C++代码之间获得这种兼容性

46
00:03:20,070 --> 00:03:24,020
因为理想情况下你应该已经能够使用C代码

47
00:03:24,024 --> 00:03:26,062
然后用类来替换结构并使其变为公有

48
00:03:26,065 --> 00:03:31,085
然后就是这样，这就是最终结果，在实际情况中不会有更多的不同

49
00:03:31,099 --> 00:03:34,010
所以从语义来说

50
00:03:34,014 --> 00:03:39,014
如果它们没有区别，那么人们又是怎么来归纳它们的使用率的

51
00:03:39,026 --> 00:03:46,005
我什么时候使用struct和class？如果我想要我的成员全部公开，而我不想要写public这个单词

52
00:03:46,005 --> 00:03:47,050
我是否应该使用struct？

53
00:03:47,050 --> 00:03:50,010
这真的不重要吗？确实是这样

54
00:03:50,031 --> 00:03:52,075
它确实不重要

55
00:03:52,075 --> 00:03:55,048
因为人们有他们每个人自己的定义

56
00:03:55,053 --> 00:04:00,005
我认为一个结构体应该是什么，我认为一个类应该是什么。

57
00:04:00,014 --> 00:04:00,082
然而

58
00:04:01,005 --> 00:04:05,007
没有什么正确或者错误的答案

59
00:04:05,026 --> 00:04:08,090
这是个人编程的风格，所以在我的视频里

60
00:04:09,006 --> 00:04:14,002
让我们来谈论一下我编程的风格，我会在哪里使用哪种类型

61
00:04:14,023 --> 00:04:23,075
基本上当我谈论一些plain old data（pod）时，我喜欢尽可能多的使用struct。我只是在谈论某种结构

62
00:04:23,075 --> 00:04:26,008
仅仅代表变量，一堆变量

63
00:04:26,026 --> 00:04:32,020
这就是它的意义。一个很好的例子可能是数学中的向量类

64
00:04:32,031 --> 00:04:33,038
如果我在这里

65
00:04:33,038 --> 00:04:40,012
我想要定义一个结构，将两个浮点数放在一起，比如说Vec2

66
00:04:40,024 --> 00:04:45,035
我可以把它定义为一个结构，里面只有我的两个浮点数x和y

67
00:04:45,035 --> 00:04:55,073
为什么从根本上说这个Vec2类或结构或任何你想叫的称呼，这个Vec2结构只是两个浮点数的表现形式

68
00:04:55,093 --> 00:04:56,077
这就是它的核心

69
00:04:56,096 --> 00:05:02,027
它不应该像player类那样包含大量的功能，它应该用在哪里？

70
00:05:02,031 --> 00:05:05,092
让它看起来像一个player类，很可能有一个3D模型

71
00:05:05,092 --> 00:05:07,048
它可能会处理3D模型里所有的渲染代码

72
00:05:07,067 --> 00:05:13,040
它可能处理一些，像玩家在地图上如何移动、接受键盘的输入等等

73
00:05:13,053 --> 00:05:21,008
这有太多的功能。然而我们这是什么，它仅仅是将两个变量按字面上组合起来

74
00:05:21,015 --> 00:05:23,088
只是为了

75
00:05:24,001 --> 00:05:28,038
使我们的代码更易于使用。这就是我们做的全部

76
00:05:28,038 --> 00:05:31,083
当然这不是说我不打算在里面添加方法

77
00:05:31,083 --> 00:05:33,020
我绝对会的

78
00:05:33,028 --> 00:05:41,035
我可能会添加一个叫做add的方法，该方法接受另外一个Vec2，然后像这样将它和目前的向量相加

79
00:05:41,056 --> 00:05:44,018
但是我在这里做的就是

80
00:05:44,018 --> 00:05:51,057
操纵这些变量，我只是添加了一个可以操作这些变量的函数，但是一天结束后

81
00:05:51,059 --> 00:05:56,023
我现在还是在讨论这两个变量，当然，如果你将他们分解之后思考的话

82
00:05:56,040 --> 00:05:59,000
很困难，你可能会反驳

83
00:05:59,034 --> 00:06:03,085
在一天结束的时候，甚至player类也只是在操纵这些变量

84
00:06:03,099 --> 00:06:06,092
然而，确实在设计上有点不同

85
00:06:07,004 --> 00:06:11,073
因为我们正在讨论一些很复杂的东西。

86
00:06:11,073 --> 00:06:13,042
另一个是继承

87
00:06:13,050 --> 00:06:17,000
我绝对不会对结构体使用继承

88
00:06:17,011 --> 00:06:22,098
如果我真的要用一个完整的类层次或某种继承层次

89
00:06:23,013 --> 00:06:25,027
我将会使用类

90
00:06:25,053 --> 00:06:31,085
因为继承又增加了另一层复杂性，而我只是希望我的结构体仅仅是数据的结构体

91
00:06:32,017 --> 00:06:34,098
就是这样。另外，如果你想要尝试并混合它们

92
00:06:35,002 --> 00:06:38,038
举个例子，你有一个类叫做A，有一个结构体叫做B

93
00:06:38,042 --> 00:06:43,042
它从A处继承，一些编译器会向你发出警告，警告你正在从一个类继承

94
00:06:43,059 --> 00:06:49,055
但是你是一个结构体，还有一些细微的差别，但是，它们只是警告你，你的代码仍然可以运行

95
00:06:49,061 --> 00:06:55,088
这只是语义上的差别，这些就是我使用类还是结构体的一些原因。

96
00:06:56,010 --> 00:06:59,052
如果我只是想要代替一个结构中的一些数据

97
00:06:59,084 --> 00:07:00,065
我会使用struct

98
00:07:00,089 --> 00:07:03,050
如果我有一个很多功能的类

99
00:07:03,076 --> 00:07:10,085
像在游戏世界里，一个玩家，或者是其他可能继承的东西

100
00:07:10,089 --> 00:07:15,085
我会再次使用类。这就是我个人如何区分这两个类型的

101
00:07:15,093 --> 00:07:20,027
我在行业内见到很多人就是这么区分这两种类型的

102
00:07:20,035 --> 00:07:27,073
但是如果如技术上来讲，如果两者除了可见性之外没有什么区别的话，你可以在任何你使用类的地方使用结构体

103
00:07:27,087 --> 00:07:29,057
它们将以相同方式工作

104
00:07:29,080 --> 00:07:35,073
希望你们喜欢这个视频，如果你喜欢的话，点赞或者你可以在Twitter和Instagram关注我

105
00:07:35,083 --> 00:07:41,033
如果您真的喜欢这些视频，并且希望支持本系列并查看更多内容，下面的说明中提供的有相关链接

106
00:07:41,067 --> 00:07:44,065
然后可以在patreon.com/thecherno关注我

107
00:07:44,078 --> 00:07:47,062
此外，你还可以支持我并激励我可以制作更多的视频

108
00:07:47,094 --> 00:07:53,052
您还可以访问早期草稿和讨论板，我们在其中讨论这些视频的内容

109
00:07:53,064 --> 00:07:56,057
如果你对此感兴趣，请查看简介中的链接

110
00:07:58,017 --> 00:08:00,095
下次我们继续我们的旅程

111
00:08:00,095 --> 00:08:06,023
至于哪种类会涉及继承的内容和查看一些现有代码的示例

112
00:08:06,046 --> 00:08:09,040
以了解应该如何构造你的类

113
00:08:09,072 --> 00:08:13,050
怎么编写它们和怎么在代码中使用它们，我将会在下次见面，再见！

